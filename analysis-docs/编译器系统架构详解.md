# LiveCodes 编译器系统架构详解

## 概述

LiveCodes 的编译器系统是其核心创新之一，实现了在浏览器中支持 90+ 种编程语言的编译和执行。这个系统采用了模块化、插件化的架构设计，通过统一的接口规范支持不同类型的编译器。

## 核心设计理念

### 1. 统一的语言规范接口

所有语言都遵循统一的 `LanguageSpecs` 接口：

```typescript
export interface LanguageSpecs {
  name: Language;                    // 语言名称
  title: string;                     // 显示标题
  longTitle?: string;                // 完整标题
  compiler: Compiler | Language;     // 编译器配置
  extensions: Language[];            // 文件扩展名
  editor: EditorId;                  // 所属编辑器（markup/style/script）
  editorLanguage?: Language;         // 编辑器语言（用于语法高亮）
  largeDownload?: boolean;           // 是否为大型下载
}
```

### 2. 多种编译器类型支持

LiveCodes 支持四种主要的编译器类型：

#### A. JavaScript 编译器
直接在浏览器主线程中运行的编译器：

```typescript
// TypeScript 编译器示例
export const typescript: LanguageSpecs = {
  name: 'typescript',
  title: 'TS',
  compiler: {
    url: typescriptUrl,
    factory: () => async (code, { config }) =>
      (window as any).ts.transpile(code, {
        target: 'ES2020',
        module: 'ESNext',
        jsx: 'react-jsx',
        ...getLanguageCustomSettings('typescript', config),
      }),
  },
  extensions: ['ts', 'typescript'],
  editor: 'script',
};
```

#### B. Web Workers 编译器
在后台线程中运行的编译器，避免阻塞主线程：

```typescript
// Solid.js 编译器示例
export const solid: LanguageSpecs = {
  name: 'solid',
  title: 'Solid',
  compiler: {
    factory: (_config, baseUrl) => {
      // 在 Web Worker 中加载编译器
      (self as any).importScripts(baseUrl + '{{hash:lang-solid-compiler.js}}');
      return (self as any).createSolidCompiler();
    },
  },
  extensions: ['solid.jsx'],
  editor: 'script',
};
```

#### C. WebAssembly 编译器
使用 WebAssembly 运行时执行的语言：

```typescript
// Python (Pyodide) 编译器示例
export const pythonWasm: LanguageSpecs = {
  name: 'python-wasm',
  title: 'Python (Wasm)',
  compiler: {
    factory: () => async (code) => code, // 代码不需要编译
    scripts: ({ baseUrl }) => [
      baseUrl + 'pyodide/pyodide.js',    // Pyodide 运行时
    ],
    scriptType: 'text/python-wasm',      // 自定义脚本类型
    compiledCodeLanguage: 'python',      // 编译后的语言
  },
  extensions: ['py'],
  editor: 'script',
};
```

#### D. 外部服务编译器
调用外部 API 进行编译的语言（较少使用）。

## 编译器加载机制

### 1. 动态编译器加载

编译器采用懒加载策略，只有在需要时才加载：

```typescript
const loadLanguageCompiler = async (language: Language, config: Config) => {
  const specs = getLanguageSpecs(language);
  if (!specs?.compiler) return;
  
  // 检查是否已加载
  if (compilers[language]?.loaded) return;
  
  // 动态加载编译器脚本
  if (typeof specs.compiler === 'object' && specs.compiler.url) {
    await loadScript(specs.compiler.url);
    
    // 创建编译器实例
    const factory = specs.compiler.factory;
    if (factory) {
      compilers[language] = {
        fn: await factory(config, baseUrl),
        loaded: true,
        specs
      };
    }
  }
};
```

### 2. 编译器工厂模式

使用工厂模式创建编译器实例：

```typescript
interface CompilerFactory {
  (config: Config, baseUrl: string): Promise<CompilerFunction> | CompilerFunction;
}

interface CompilerFunction {
  (code: string, options: CompileOptions): Promise<string | CompileResult>;
}

// 编译器工厂示例
const createTypeScriptCompiler: CompilerFactory = () => {
  return async (code, { config }) => {
    return (window as any).ts.transpile(code, {
      ...getCompilerOptions(config),
    });
  };
};
```

## 编译流程详解

### 1. 编译请求处理

```typescript
const compile = async (
  content: string,
  language: Language,
  config: Config,
  options: CompileOptions,
): Promise<CompileResult> => {
  // 1. 语言映射处理
  if (['jsx', 'tsx'].includes(language)) {
    language = 'typescript';
  }

  // 2. 获取激活的处理器
  const enabledProcessors = getActivatedProcessors(language, config);
  const languageSettings = stringify(getCustomSettings(language, config));

  // 3. 检查缓存
  if (!options?.forceCompile && isCacheValid(language, content, enabledProcessors, languageSettings)) {
    return getCachedResult(language);
  }

  // 4. 加载编译器
  if (compilers[language] && !compilers[language].fn) {
    await load([language], config);
  }

  // 5. 执行编译
  const compiler = compilers[language]?.fn;
  if (typeof compiler !== 'function') {
    return handleCompilerError(language);
  }

  const compiled = getCompileResult(
    await compiler(content, { config, language, baseUrl, options })
  ) || '';

  // 6. 后处理
  const processed = getCompileResult(
    await postProcess(compiled.code, { config, language, baseUrl, options })
  ) || '';

  // 7. 合并结果和缓存
  const result = {
    code: processed.code,
    info: { ...compiled.info, ...processed.info },
  };

  updateCache(language, content, enabledProcessors, languageSettings, result);
  return result;
};
```

### 2. Web Workers 编译

为了避免阻塞主线程，大型编译任务在 Web Workers 中执行：

```typescript
// compile.worker.ts
const compileInWorker = async (
  content: string,
  language: LanguageOrProcessor,
  config: Config,
  options: CompileOptions,
) => {
  const compiler = compilers[language]?.fn;
  if (!baseUrl || typeof compiler !== 'function') {
    throw new Error('Failed to load compiler for: ' + language);
  }

  let value;
  try {
    value = await compiler(content, { config, language, baseUrl, options });
  } catch (err) {
    console.error('Failed compiling: ' + language, err);
    value = content; // 回退到原始代码
  }
  return value || '';
};

// 主线程中调用 Worker
const compileWithWorker = (code: string, language: Language) => {
  return new Promise((resolve, reject) => {
    const worker = new Worker('./compile.worker.js');
    
    worker.postMessage({ code, language, config: getConfig() });
    
    worker.onmessage = (e) => {
      resolve(e.data.result);
      worker.terminate();
    };
    
    worker.onerror = (error) => {
      reject(error);
      worker.terminate();
    };
  });
};
```

## 具体语言实现案例

### 1. TypeScript 编译器

TypeScript 是最常用的编译器之一，直接使用官方的 TypeScript 编译器：

```typescript
export const typescript: LanguageSpecs = {
  name: 'typescript',
  title: 'TS',
  longTitle: 'TypeScript',
  parser: {
    name: 'babel-ts',
    pluginUrls: [parserPlugins.babel, parserPlugins.html],
  },
  compiler: {
    url: typescriptUrl, // TypeScript 编译器 URL
    factory: () => async (code, { config }) => {
      const options = {
        target: 'ES2020',
        module: 'ESNext',
        moduleResolution: 'node',
        allowSyntheticDefaultImports: true,
        esModuleInterop: true,
        ...(['jsx', 'tsx'].includes(config.script.language) && !hasCustomJsxRuntime(code, config)
          ? { jsx: 'react-jsx' }
          : {}),
        ...getLanguageCustomSettings('typescript', config),
        ...getLanguageCustomSettings(config.script.language, config),
      };
      
      return (window as any).ts.transpile(code, options);
    },
  },
  extensions: ['ts', 'typescript'],
  editor: 'script',
};
```

### 2. Vue.js 单文件组件编译器

Vue SFC 需要特殊的编译处理，将模板、脚本和样式分别编译：

```typescript
export const vue: LanguageSpecs = {
  name: 'vue',
  title: 'Vue 3 SFC',
  compiler: {
    factory: (_config, baseUrl) => {
      (self as any).importScripts(baseUrl + '{{hash:lang-vue-compiler.js}}');
      return (self as any).createVueCompiler();
    },
  },
  extensions: ['vue'],
  editor: 'script',
};

// Vue 编译器实现
const createVueCompiler = (): CompilerFunction => {
  return async (code, { config }) => {
    const { compile, compileTemplate, compileScript, compileStyle } = (self as any).VueCompiler;
    
    // 解析 SFC
    const { descriptor } = compile(code);
    
    let compiledScript = '';
    let compiledTemplate = '';
    let compiledStyles = '';
    
    // 编译脚本部分
    if (descriptor.script || descriptor.scriptSetup) {
      const scriptResult = compileScript(descriptor, {
        id: 'component',
        ...getLanguageCustomSettings('vue', config),
      });
      compiledScript = scriptResult.content;
    }
    
    // 编译模板部分
    if (descriptor.template) {
      const templateResult = compileTemplate({
        source: descriptor.template.content,
        id: 'component',
        filename: 'component.vue',
      });
      compiledTemplate = templateResult.code;
    }
    
    // 编译样式部分
    if (descriptor.styles.length > 0) {
      const styleResults = descriptor.styles.map(style => 
        compileStyle({
          source: style.content,
          id: 'component',
          scoped: style.scoped,
        })
      );
      compiledStyles = styleResults.map(r => r.code).join('\n');
    }
    
    // 组合最终代码
    return combineVueComponent(compiledScript, compiledTemplate, compiledStyles);
  };
};
```

### 3. WebAssembly 语言支持 (Python/Pyodide)

Python 通过 Pyodide 在 WebAssembly 中运行：

```typescript
export const pythonWasm: LanguageSpecs = {
  name: 'python-wasm',
  title: 'Python (Wasm)',
  compiler: {
    factory: () => async (code) => code, // Python 代码不需要编译
    scripts: ({ baseUrl }) => [
      baseUrl + 'pyodide/pyodide.js',
    ],
    scriptType: 'text/python-wasm',
    compiledCodeLanguage: 'python',
    inlineModule: `
      // 初始化 Pyodide
      async function loadPyodideAndPackages() {
        self.pyodide = await loadPyodide();
        // 预加载常用包
        await self.pyodide.loadPackage(['numpy', 'pandas', 'matplotlib']);
      }
      loadPyodideAndPackages();
    `,
  },
  extensions: ['py'],
  editor: 'script',
  largeDownload: true, // 标记为大型下载
};

// Python 代码执行
const executePythonCode = async (code: string) => {
  if (!self.pyodide) {
    await loadPyodideAndPackages();
  }

  try {
    // 重定向 stdout 到控制台
    self.pyodide.runPython(`
      import sys
      from io import StringIO
      sys.stdout = StringIO()
    `);

    // 执行用户代码
    self.pyodide.runPython(code);

    // 获取输出
    const output = self.pyodide.runPython('sys.stdout.getvalue()');
    if (output) {
      console.log(output);
    }
  } catch (error) {
    console.error('Python execution error:', error);
  }
};
```

### 4. AssemblyScript 编译器

AssemblyScript 编译为 WebAssembly：

```typescript
export const assemblyscript: LanguageSpecs = {
  name: 'assemblyscript',
  title: 'AS',
  longTitle: 'AssemblyScript',
  compiler: {
    url: assemblyscriptUrl,
    factory: (_config, baseUrl) => {
      (self as any).importScripts(baseUrl + '{{hash:lang-assemblyscript-compiler.js}}');
      return (self as any).createAssemblyscriptCompiler();
    },
    scripts: ({ baseUrl }) => [
      assemblyscriptLoaderUrl,
      baseUrl + '{{hash:lang-assemblyscript-script.js}}',
    ],
    scriptType: 'application/wasm-uint8',
    compiledCodeLanguage: 'wat', // WebAssembly Text Format
    types: {
      assemblyscript: {
        url: vendorsBaseUrl + 'types/assemblyscript.d.ts',
        declareAsModule: false,
        autoload: true,
      },
    },
  },
  extensions: ['as', 'ts'],
  editor: 'script',
  editorLanguage: 'typescript',
};

// AssemblyScript 编译器实现
const createAssemblyscriptCompiler = (): CompilerFunction => {
  return async (code: string, { config }) => {
    await self.assemblyscriptLoaded; // 等待 AssemblyScript 加载完成

    try {
      const options = {
        optimize: true,
        shrinkLevel: 1,
        ...getLanguageCustomSettings('assemblyscript', config),
      };

      const { text, binary } = await self.assemblyscript.asc.compileString(code, options);

      if (!binary) return '';

      // 返回 WAT 格式和二进制数据
      const watHeader = `;; WebAssembly Text Format (module.wat)\n\n`;
      const wasmHeader = `\n\n;; WebAssembly Binary (module.wasm)\n;; `;
      const arrayString = binary.toString();

      return watHeader + text + wasmHeader + 'Uint8Array [' + arrayString + ']';
    } catch (err) {
      console.error('AssemblyScript compilation error:', err);
      return '';
    }
  };
};
```

## 缓存机制

### 1. 编译缓存策略

为了提高性能，LiveCodes 实现了智能的编译缓存：

```typescript
interface CompileCache {
  content: string;           // 源代码内容
  compiled: string;          // 编译结果
  processors: string;        // 激活的处理器
  languageSettings: string;  // 语言设置
  timestamp: number;         // 缓存时间戳
  info: CompileInfo;         // 编译信息
}

const cache = new Map<Language, CompileCache>();

// 检查缓存是否有效
const isCacheValid = (
  language: Language,
  content: string,
  processors: string,
  settings: string
): boolean => {
  const cached = cache.get(language);
  return !!(
    cached &&
    cached.content === content &&
    cached.processors === processors &&
    cached.languageSettings === settings &&
    Date.now() - cached.timestamp < CACHE_EXPIRY
  );
};

// 更新缓存
const updateCache = (
  language: Language,
  content: string,
  processors: string,
  settings: string,
  result: CompileResult
) => {
  cache.set(language, {
    content,
    compiled: result.code,
    processors,
    languageSettings: settings,
    timestamp: Date.now(),
    info: result.info || {},
  });
};
```

### 2. 模块缓存

编译器模块也会被缓存以避免重复加载：

```typescript
const moduleCache = new Map<string, any>();

const loadModule = async (url: string): Promise<any> => {
  if (moduleCache.has(url)) {
    return moduleCache.get(url);
  }

  try {
    const module = await import(url);
    moduleCache.set(url, module);
    return module;
  } catch (error) {
    console.error(`Failed to load module: ${url}`, error);
    throw error;
  }
};
```

## 错误处理和回退机制

### 1. 编译错误处理

```typescript
const handleCompilerError = (language: Language, error?: Error): CompileResult => {
  const errorMessage = error?.message || `Failed to load compiler for: ${language}`;

  // 记录错误
  console.error(errorMessage, error);

  // 发送错误报告（生产环境）
  if (process.env.NODE_ENV === 'production') {
    sendErrorReport({
      type: 'compiler_error',
      language,
      error: errorMessage,
      stack: error?.stack,
    });
  }

  // 返回空结果
  return {
    code: '',
    info: {
      error: errorMessage,
      language,
    },
  };
};
```

### 2. 回退策略

当编译器加载失败时，系统会尝试回退策略：

```typescript
const compileWithFallback = async (
  code: string,
  language: Language,
  config: Config
): Promise<CompileResult> => {
  try {
    // 尝试主编译器
    return await compile(code, language, config, {});
  } catch (primaryError) {
    console.warn(`Primary compiler failed for ${language}, trying fallback`);

    try {
      // 尝试回退编译器
      const fallbackLanguage = getFallbackLanguage(language);
      if (fallbackLanguage && fallbackLanguage !== language) {
        return await compile(code, fallbackLanguage, config, {});
      }
    } catch (fallbackError) {
      console.error(`Fallback compiler also failed for ${language}`);
    }

    // 最终回退：返回原始代码
    return {
      code,
      info: {
        warning: `Compilation failed, using original code`,
        originalError: primaryError.message,
      },
    };
  }
};

// 获取回退语言
const getFallbackLanguage = (language: Language): Language | null => {
  const fallbackMap: Record<string, Language> = {
    'typescript': 'javascript',
    'jsx': 'javascript',
    'tsx': 'typescript',
    'coffeescript': 'javascript',
    'livescript': 'javascript',
    // ... 更多映射
  };

  return fallbackMap[language] || null;
};
```

## 性能优化策略

### 1. 懒加载和预加载

```typescript
// 懒加载：只在需要时加载编译器
const lazyLoadCompiler = async (language: Language) => {
  if (!compilers[language]) {
    await loadLanguageCompiler(language, getConfig());
  }
  return compilers[language];
};

// 预加载：预测用户可能使用的编译器
const preloadPopularCompilers = async () => {
  const popularLanguages = ['javascript', 'typescript', 'html', 'css', 'markdown'];

  // 并行预加载，但不阻塞主流程
  Promise.allSettled(
    popularLanguages.map(lang => loadLanguageCompiler(lang, getConfig()))
  ).then(() => {
    console.log('Popular compilers preloaded');
  });
};
```

### 2. 编译优化

```typescript
// 增量编译：只编译变更的部分
const incrementalCompile = async (
  newCode: string,
  oldCode: string,
  language: Language
): Promise<CompileResult> => {
  // 计算代码差异
  const diff = calculateDiff(oldCode, newCode);

  if (diff.isMinimal) {
    // 小幅变更，尝试增量编译
    const cachedResult = getCachedResult(language);
    if (cachedResult) {
      return applyIncrementalChanges(cachedResult, diff);
    }
  }

  // 大幅变更，执行完整编译
  return compile(newCode, language, getConfig(), {});
};

// 并行编译：同时编译多个文件
const parallelCompile = async (
  files: Array<{ code: string; language: Language }>
): Promise<CompileResult[]> => {
  return Promise.all(
    files.map(file => compile(file.code, file.language, getConfig(), {}))
  );
};
```

## 总结

LiveCodes 的编译器系统通过以下关键设计实现了对 90+ 种语言的支持：

1. **统一接口规范**：所有语言遵循相同的 `LanguageSpecs` 接口
2. **多种编译器类型**：支持 JavaScript、Web Workers、WebAssembly 等不同运行环境
3. **动态加载机制**：按需加载编译器，减少初始加载时间
4. **智能缓存策略**：避免重复编译，提高性能
5. **错误处理和回退**：确保系统的稳定性和可用性
6. **性能优化**：懒加载、预加载、增量编译等优化策略

这个架构的优势在于：
- **可扩展性**：添加新语言支持只需实现 `LanguageSpecs` 接口
- **性能优化**：通过缓存和懒加载最小化资源消耗
- **稳定性**：完善的错误处理和回退机制
- **灵活性**：支持多种编译器类型和执行环境

这种设计使得 LiveCodes 能够在浏览器中提供接近本地开发环境的体验，同时保持良好的性能和稳定性。
```
