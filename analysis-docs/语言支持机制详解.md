# LiveCodes 语言支持机制详解

## 概述

LiveCodes 支持 90+ 种编程语言和框架，这得益于其灵活的语言支持机制。该机制通过统一的接口规范、模块化的编译器架构和智能的加载策略，实现了对多种语言的无缝支持。

## 语言分类体系

### 1. 按编辑器分类

LiveCodes 将语言按照用途分为三个编辑器：

```typescript
export type EditorId = 'markup' | 'style' | 'script';

// 标记语言 (markup)
const markupLanguages = [
  'html', 'markdown', 'mdx', 'pug', 'haml', 'mustache', 
  'handlebars', 'ejs', 'nunjucks', 'liquid', 'asciidoc',
  'bbcode', 'dot', 'twig', 'vento', 'art-template', 'jinja'
];

// 样式语言 (style)  
const styleLanguages = [
  'css', 'scss', 'sass', 'less', 'stylus', 'postcss',
  'tailwindcss', 'windicss', 'unocss', 'lightningcss', 'stylis'
];

// 脚本语言 (script)
const scriptLanguages = [
  'javascript', 'typescript', 'jsx', 'tsx', 'coffeescript',
  'livescript', 'python', 'python-wasm', 'ruby', 'ruby-wasm',
  'php', 'php-wasm', 'go', 'rust', 'cpp', 'cpp-wasm',
  'csharp-wasm', 'java', 'kotlin', 'scala', 'clojure',
  'clojurescript', 'reason', 'rescript', 'ocaml', 'fsharp',
  'elm', 'purescript', 'haskell', 'scheme', 'racket',
  'lua', 'lua-wasm', 'perl', 'r', 'julia', 'dart',
  'assemblyscript', 'wat', 'gleam', 'civet', 'imba',
  'solid', 'solid.tsx', 'svelte', 'vue', 'vue2', 'react',
  'react.tsx', 'react-native', 'react-native.tsx', 'stencil',
  'lit', 'riot', 'malina', 'astro', 'blockly', 'prolog',
  'tcl', 'fennel', 'teal', 'commonlisp', 'clio'
];
```

### 2. 按执行方式分类

#### A. 客户端编译语言
直接在浏览器中编译执行：

```typescript
// TypeScript/JavaScript 系列
const clientCompiledLanguages = [
  'typescript', 'jsx', 'tsx', 'coffeescript', 'livescript',
  'babel', 'sucrase', 'flow'
];

// CSS 预处理器
const cssPreprocessors = [
  'scss', 'sass', 'less', 'stylus', 'postcss'
];

// 模板语言
const templateLanguages = [
  'pug', 'haml', 'mustache', 'handlebars', 'ejs',
  'nunjucks', 'liquid', 'twig', 'eta'
];
```

#### B. WebAssembly 语言
通过 WebAssembly 运行时执行：

```typescript
const wasmLanguages = [
  'python-wasm',    // Pyodide
  'ruby-wasm',      // ruby.wasm
  'php-wasm',       // php-wasm
  'lua-wasm',       // Wasmoon
  'cpp-wasm',       // Emscripten
  'csharp-wasm',    // Blazor
  'assemblyscript', // AssemblyScript
  'wat',            // WebAssembly Text Format
];
```

#### C. 框架特定语言
需要特定框架支持的语言：

```typescript
const frameworkLanguages = [
  'vue',            // Vue.js SFC
  'svelte',         // Svelte 组件
  'solid',          // Solid.js
  'react',          // React JSX
  'stencil',        // Stencil 组件
  'lit',            // Lit 元素
  'astro',          // Astro 组件
];
```

## 语言定义规范

### 1. LanguageSpecs 接口

每种语言都必须实现 `LanguageSpecs` 接口：

```typescript
export interface LanguageSpecs {
  name: Language;                    // 语言标识符
  title: string;                     // 短标题
  longTitle?: string;                // 完整标题
  info?: boolean;                    // 是否显示信息按钮
  parser?: Parser;                   // 代码解析器配置
  formatter?: LanguageFormatter;     // 代码格式化器
  compiler: Compiler | Language;     // 编译器配置
  extensions: Language[];            // 文件扩展名
  editor: EditorId;                  // 所属编辑器
  editorLanguage?: Language;         // 编辑器语言（语法高亮）
  preset?: CssPresetId;             // CSS 预设
  largeDownload?: boolean;           // 大型下载标记
}
```

### 2. 编译器配置类型

```typescript
export interface Compiler {
  url?: string;                      // 编译器脚本 URL
  factory?: CompilerFactory;         // 编译器工厂函数
  scripts?: ScriptLoader;            // 运行时脚本
  scriptType?: string;               // 脚本类型
  compiledCodeLanguage?: Language;   // 编译后语言
  inlineModule?: string;             // 内联模块代码
  loadAsExternalModule?: boolean;    // 作为外部模块加载
  types?: Types;                     // TypeScript 类型定义
}

export interface CompilerFactory {
  (config: Config, baseUrl: string): Promise<CompilerFunction> | CompilerFunction;
}

export interface CompilerFunction {
  (code: string, options: CompileOptions): Promise<string | CompileResult>;
}
```

## 具体语言实现案例

### 1. TypeScript 实现

TypeScript 是最基础的编译语言之一：

```typescript
import { typescriptUrl } from '../../vendors';
import { getLanguageCustomSettings } from '../../utils';
import { hasCustomJsxRuntime } from '../jsx/utils';

export const typescript: LanguageSpecs = {
  name: 'typescript',
  title: 'TS',
  longTitle: 'TypeScript',
  parser: {
    name: 'babel-ts',
    pluginUrls: [parserPlugins.babel, parserPlugins.html],
  },
  compiler: {
    url: typescriptUrl,
    factory: () => async (code, { config }) => {
      const options = {
        target: 'ES2020',
        module: 'ESNext',
        moduleResolution: 'node',
        allowSyntheticDefaultImports: true,
        esModuleInterop: true,
        skipLibCheck: true,
        ...(['jsx', 'tsx'].includes(config.script.language) && !hasCustomJsxRuntime(code, config)
          ? { jsx: 'react-jsx' }
          : {}),
        ...getLanguageCustomSettings('typescript', config),
        ...getLanguageCustomSettings(config.script.language, config),
      };
      
      return (window as any).ts.transpile(code, options);
    },
  },
  extensions: ['ts', 'typescript'],
  editor: 'script',
};
```

### 2. Vue.js 单文件组件

Vue SFC 需要复杂的编译处理：

```typescript
export const vue: LanguageSpecs = {
  name: 'vue',
  title: 'Vue 3 SFC',
  compiler: {
    factory: (_config, baseUrl) => {
      (self as any).importScripts(baseUrl + '{{hash:lang-vue-compiler.js}}');
      return (self as any).createVueCompiler();
    },
  },
  extensions: ['vue'],
  editor: 'script',
};

// Vue 编译器实现 (lang-vue-compiler.ts)
(self as any).createVueCompiler = (): CompilerFunction => {
  const { compile, compileScript, compileTemplate, compileStyle } = (self as any).VueCompiler;
  
  return async (code, { config }) => {
    try {
      // 解析 SFC
      const { descriptor, errors } = compile(code, { filename: 'component.vue' });
      
      if (errors.length > 0) {
        console.error('Vue SFC parse errors:', errors);
      }
      
      let scriptContent = '';
      let templateContent = '';
      let stylesContent = '';
      
      // 编译脚本部分
      if (descriptor.script || descriptor.scriptSetup) {
        const scriptResult = compileScript(descriptor, {
          id: 'component',
          inlineTemplate: !descriptor.template,
          templateOptions: {
            compilerOptions: {
              mode: 'module',
            },
          },
          ...getLanguageCustomSettings('vue', config),
        });
        scriptContent = scriptResult.content;
      }
      
      // 编译模板部分
      if (descriptor.template && !descriptor.scriptSetup) {
        const templateResult = compileTemplate({
          source: descriptor.template.content,
          id: 'component',
          filename: 'component.vue',
          compilerOptions: {
            mode: 'module',
          },
        });
        templateContent = templateResult.code;
      }
      
      // 编译样式部分
      if (descriptor.styles.length > 0) {
        const stylePromises = descriptor.styles.map(async (style, index) => {
          const styleResult = compileStyle({
            source: style.content,
            id: `component-${index}`,
            filename: 'component.vue',
            scoped: style.scoped,
            modules: style.module,
          });
          return styleResult.code;
        });
        
        const styleResults = await Promise.all(stylePromises);
        stylesContent = styleResults.join('\n');
      }
      
      // 组合最终代码
      return generateVueComponent(scriptContent, templateContent, stylesContent);
      
    } catch (error) {
      console.error('Vue compilation error:', error);
      return `console.error('Vue compilation failed: ${error.message}');`;
    }
  };
};

// 生成最终的 Vue 组件代码
const generateVueComponent = (
  script: string,
  template: string,
  styles: string
): string => {
  return `
// Vue 3 Component
${script}

// 注入样式
if (typeof document !== 'undefined') {
  const style = document.createElement('style');
  style.textContent = \`${styles}\`;
  document.head.appendChild(style);
}

// 导出组件
export default component;
`.trim();
};
```

### 3. Python (Pyodide) 实现

Python 通过 Pyodide 在 WebAssembly 中运行：

```typescript
export const pythonWasm: LanguageSpecs = {
  name: 'python-wasm',
  title: 'Python (Wasm)',
  compiler: {
    factory: () => async (code) => code, // Python 代码不需要编译
    scripts: ({ baseUrl }) => [
      baseUrl + 'pyodide/pyodide.js',
    ],
    scriptType: 'text/python-wasm',
    compiledCodeLanguage: 'python',
    inlineModule: `
      // 初始化 Pyodide
      let pyodideReady = false;
      
      async function initPyodide() {
        if (pyodideReady) return;
        
        try {
          self.pyodide = await loadPyodide({
            indexURL: '${baseUrl}pyodide/',
          });
          
          // 预加载常用包
          await self.pyodide.loadPackage([
            'numpy', 'pandas', 'matplotlib', 'scipy'
          ]);
          
          // 设置输出重定向
          self.pyodide.runPython(\`
import sys
import io
from contextlib import redirect_stdout, redirect_stderr

class ConsoleCapture:
    def __init__(self):
        self.output = []
    
    def write(self, text):
        if text.strip():
            self.output.append(text.strip())
            console.log(text.strip())
    
    def flush(self):
        pass

console_capture = ConsoleCapture()
          \`);
          
          pyodideReady = true;
          console.log('Pyodide initialized successfully');
        } catch (error) {
          console.error('Failed to initialize Pyodide:', error);
        }
      }
      
      // 执行 Python 代码
      async function runPython(code) {
        await initPyodide();
        
        try {
          self.pyodide.runPython(\`
sys.stdout = console_capture
sys.stderr = console_capture
console_capture.output = []
          \`);
          
          // 执行用户代码
          const result = self.pyodide.runPython(code);
          
          // 如果有返回值，显示它
          if (result !== undefined && result !== null) {
            console.log(result);
          }
          
        } catch (error) {
          console.error('Python execution error:', error.message);
        }
      }
      
      // 自动初始化
      initPyodide();
    `,
  },
  extensions: ['py'],
  editor: 'script',
  largeDownload: true,
};
```

### 4. Svelte 组件实现

Svelte 需要特殊的编译处理：

```typescript
export const svelte: LanguageSpecs = {
  name: 'svelte',
  title: 'Svelte',
  compiler: {
    factory: (_config, baseUrl) => {
      (self as any).importScripts(baseUrl + '{{hash:lang-svelte-compiler.js}}');
      return (self as any).createSvelteCompiler();
    },
  },
  extensions: ['svelte'],
  editor: 'script',
};

// Svelte 编译器实现
(self as any).createSvelteCompiler = (): CompilerFunction => {
  const { compile } = (self as any).svelte;
  
  return async (code, { config }) => {
    try {
      const options = {
        generate: 'dom',
        hydratable: true,
        dev: false,
        css: 'injected',
        ...getLanguageCustomSettings('svelte', config),
      };
      
      const result = compile(code, options);
      
      if (result.warnings.length > 0) {
        result.warnings.forEach(warning => {
          console.warn('Svelte warning:', warning.message);
        });
      }
      
      // 生成最终代码
      return `
// Svelte Component
${result.js.code}

// 导出组件类
export default Component;
      `.trim();
      
    } catch (error) {
      console.error('Svelte compilation error:', error);
      return `console.error('Svelte compilation failed: ${error.message}');`;
    }
  };
};
```

## 语言注册和管理

### 1. 语言注册系统

所有语言通过统一的注册系统管理：

```typescript
// src/livecodes/languages/languages.ts
import { html } from './html';
import { css } from './css';
import { javascript } from './javascript';
import { typescript } from './typescript';
// ... 导入所有语言

export const languages: LanguageSpecs[] = [
  // 标记语言
  html,
  markdown,
  mdx,
  pug,
  haml,
  // ... 更多标记语言

  // 样式语言
  css,
  scss,
  sass,
  less,
  // ... 更多样式语言

  // 脚本语言
  javascript,
  typescript,
  jsx,
  tsx,
  // ... 更多脚本语言
];

// 语言映射表
const languageMap = new Map<Language, LanguageSpecs>();
const extensionMap = new Map<string, Language>();
const aliasMap = new Map<string, Language>();

// 初始化映射表
const initializeLanguageMaps = () => {
  languages.forEach(lang => {
    languageMap.set(lang.name, lang);

    // 扩展名映射
    lang.extensions.forEach(ext => {
      extensionMap.set(ext, lang.name);
    });

    // 别名映射
    if (lang.title !== lang.name) {
      aliasMap.set(lang.title.toLowerCase(), lang.name);
    }
    if (lang.longTitle) {
      aliasMap.set(lang.longTitle.toLowerCase(), lang.name);
    }
  });
};

initializeLanguageMaps();
```

### 2. 语言查询工具

```typescript
// 根据名称获取语言规范
export const getLanguageSpecs = (language: Language): LanguageSpecs | undefined => {
  return languageMap.get(language);
};

// 根据扩展名获取语言
export const getLanguageByExtension = (extension: string): Language | undefined => {
  return extensionMap.get(extension.toLowerCase());
};

// 根据别名获取语言
export const getLanguageByAlias = (alias: string): Language | undefined => {
  const normalized = alias.toLowerCase().trim();
  return aliasMap.get(normalized) || (languageMap.has(normalized as Language) ? normalized as Language : undefined);
};

// 获取语言标题
export const getLanguageTitle = (language: Language): string => {
  const specs = getLanguageSpecs(language);
  return specs?.longTitle || specs?.title || language;
};

// 获取编辑器语言（用于语法高亮）
export const getLanguageEditorId = (language: Language): Language => {
  const specs = getLanguageSpecs(language);
  return specs?.editorLanguage || language;
};

// 检查语言是否启用
export const languageIsEnabled = (language: Language, config: Config): boolean => {
  const disabledLanguages = config.customSettings?.disabledLanguages || [];
  return !disabledLanguages.includes(language);
};
```

### 3. 动态语言加载

```typescript
// 语言编译器加载器
class LanguageLoader {
  private loadedCompilers = new Set<Language>();
  private loadingPromises = new Map<Language, Promise<void>>();

  async loadLanguage(language: Language, config: Config): Promise<void> {
    // 检查是否已加载
    if (this.loadedCompilers.has(language)) {
      return;
    }

    // 检查是否正在加载
    if (this.loadingPromises.has(language)) {
      return this.loadingPromises.get(language);
    }

    // 开始加载
    const loadPromise = this.doLoadLanguage(language, config);
    this.loadingPromises.set(language, loadPromise);

    try {
      await loadPromise;
      this.loadedCompilers.add(language);
    } finally {
      this.loadingPromises.delete(language);
    }
  }

  private async doLoadLanguage(language: Language, config: Config): Promise<void> {
    const specs = getLanguageSpecs(language);
    if (!specs?.compiler) {
      throw new Error(`No compiler found for language: ${language}`);
    }

    if (typeof specs.compiler === 'string') {
      // 引用其他语言的编译器
      return this.loadLanguage(specs.compiler, config);
    }

    const compiler = specs.compiler;

    // 加载编译器脚本
    if (compiler.url) {
      await this.loadScript(compiler.url);
    }

    // 创建编译器实例
    if (compiler.factory) {
      const compilerFn = await compiler.factory(config, getBaseUrl());
      registerCompiler(language, compilerFn, specs);
    }
  }

  private async loadScript(url: string): Promise<void> {
    return new Promise((resolve, reject) => {
      const script = document.createElement('script');
      script.src = url;
      script.onload = () => resolve();
      script.onerror = () => reject(new Error(`Failed to load script: ${url}`));
      document.head.appendChild(script);
    });
  }
}

export const languageLoader = new LanguageLoader();
```

## 处理器系统

### 1. CSS 处理器

CSS 处理器用于后处理 CSS 代码：

```typescript
// CSS 处理器定义
export const processors: ProcessorSpecs[] = [
  {
    name: 'postcss',
    title: 'PostCSS',
    isPostcssPlugin: true,
    compiler: {
      url: postcssUrl,
      factory: () => async (code, { config }) => {
        const postcss = (window as any).postcss;
        const plugins = getPostcssPlugins(config);

        const result = await postcss(plugins).process(code, {
          from: undefined,
          to: undefined,
        });

        return result.css;
      },
    },
  },
  {
    name: 'autoprefixer',
    title: 'Autoprefixer',
    isPostcssPlugin: true,
    compiler: {
      url: autoprefixerUrl,
      factory: () => async (code) => {
        const postcss = (window as any).postcss;
        const autoprefixer = (window as any).autoprefixer;

        const result = await postcss([autoprefixer]).process(code, {
          from: undefined,
          to: undefined,
        });

        return result.css;
      },
    },
  },
];

// 获取激活的处理器
export const getActivatedProcessors = (language: Language, config: Config): string => {
  const specs = getLanguageSpecs(language);
  if (!specs || specs.editor !== 'style') return '';

  const processors = config.processors || [];
  const activated = processors.filter(p => p.enabled).map(p => p.name);

  return JSON.stringify(activated.sort());
};
```

### 2. JavaScript 处理器

JavaScript 处理器用于转换 JavaScript 代码：

```typescript
// Babel 处理器
export const babel: ProcessorSpecs = {
  name: 'babel',
  title: 'Babel',
  compiler: {
    url: babelUrl,
    factory: () => async (code, { config }) => {
      const Babel = (window as any).Babel;
      const options = {
        presets: ['env'],
        plugins: [],
        ...getLanguageCustomSettings('babel', config),
      };

      const result = Babel.transform(code, options);
      return result.code;
    },
  },
};

// TypeScript 处理器
export const typescript: ProcessorSpecs = {
  name: 'typescript',
  title: 'TypeScript',
  compiler: {
    url: typescriptUrl,
    factory: () => async (code, { config }) => {
      const ts = (window as any).ts;
      const options = {
        target: ts.ScriptTarget.ES2020,
        module: ts.ModuleKind.ESNext,
        ...getLanguageCustomSettings('typescript', config),
      };

      return ts.transpile(code, options);
    },
  },
};
```

## 自定义设置系统

### 1. 语言自定义设置

每种语言都可以有自定义的编译选项：

```typescript
// 获取语言自定义设置
export const getLanguageCustomSettings = (language: Language, config: Config): any => {
  const customSettings = config.customSettings || {};
  return customSettings[language] || {};
};

// 设置语言自定义设置
export const setLanguageCustomSettings = (
  language: Language,
  settings: any,
  config: Config
): Config => {
  return {
    ...config,
    customSettings: {
      ...config.customSettings,
      [language]: {
        ...getLanguageCustomSettings(language, config),
        ...settings,
      },
    },
  };
};

// 常见的自定义设置示例
const commonCustomSettings = {
  typescript: {
    target: 'ES2020',
    module: 'ESNext',
    strict: true,
    experimentalDecorators: false,
    emitDecoratorMetadata: false,
  },
  babel: {
    presets: [['env', { modules: false }]],
    plugins: [],
  },
  postcss: {
    plugins: ['autoprefixer', 'cssnano'],
  },
  python: {
    autoloadStdlib: true,
    packages: ['numpy', 'pandas'],
  },
  vue: {
    compilerOptions: {
      mode: 'module',
    },
  },
};
```

### 2. 编译选项管理

```typescript
// 编译选项接口
export interface CompileOptions {
  forceCompile?: boolean;        // 强制重新编译
  sourceMap?: boolean;           // 生成源映射
  minify?: boolean;              // 压缩代码
  target?: string;               // 编译目标
  format?: 'esm' | 'cjs' | 'iife'; // 输出格式
  external?: string[];           // 外部依赖
}

// 获取编译选项
const getCompileOptions = (language: Language, config: Config): CompileOptions => {
  const customSettings = getLanguageCustomSettings(language, config);
  const globalOptions = config.compileOptions || {};

  return {
    ...globalOptions,
    ...customSettings.compileOptions,
  };
};
```

## 错误处理和调试

### 1. 编译错误处理

```typescript
// 编译错误类型
export interface CompileError {
  message: string;
  line?: number;
  column?: number;
  filename?: string;
  stack?: string;
}

// 错误处理器
export const handleCompileError = (
  error: Error,
  language: Language,
  code: string
): CompileResult => {
  const compileError: CompileError = {
    message: error.message,
    stack: error.stack,
  };

  // 尝试解析错误位置
  const location = parseErrorLocation(error.message);
  if (location) {
    compileError.line = location.line;
    compileError.column = location.column;
  }

  // 记录错误
  console.error(`Compilation failed for ${language}:`, compileError);

  // 发送错误报告
  if (process.env.NODE_ENV === 'production') {
    sendErrorReport({
      type: 'compile_error',
      language,
      error: compileError,
      codeLength: code.length,
    });
  }

  return {
    code: '',
    info: {
      error: compileError,
    },
  };
};

// 解析错误位置
const parseErrorLocation = (message: string): { line: number; column: number } | null => {
  // TypeScript 错误格式: "error TS2304: Cannot find name 'foo' at line 5, column 10"
  const tsMatch = message.match(/at line (\d+), column (\d+)/);
  if (tsMatch) {
    return {
      line: parseInt(tsMatch[1], 10),
      column: parseInt(tsMatch[2], 10),
    };
  }

  // Babel 错误格式: "SyntaxError: Unexpected token (5:10)"
  const babelMatch = message.match(/\((\d+):(\d+)\)/);
  if (babelMatch) {
    return {
      line: parseInt(babelMatch[1], 10),
      column: parseInt(babelMatch[2], 10),
    };
  }

  return null;
};
```

### 2. 调试工具

```typescript
// 语言调试器
export class LanguageDebugger {
  private static instance: LanguageDebugger;
  private debugMode = false;

  static getInstance(): LanguageDebugger {
    if (!this.instance) {
      this.instance = new LanguageDebugger();
    }
    return this.instance;
  }

  setDebugMode(enabled: boolean): void {
    this.debugMode = enabled;
  }

  logCompilation(language: Language, code: string, result: CompileResult): void {
    if (!this.debugMode) return;

    console.group(`🔧 Compilation: ${language}`);
    console.log('Input code:', code);
    console.log('Output code:', result.code);
    console.log('Compilation info:', result.info);
    console.groupEnd();
  }

  logError(language: Language, error: Error): void {
    if (!this.debugMode) return;

    console.group(`❌ Compilation Error: ${language}`);
    console.error('Error:', error);
    console.trace();
    console.groupEnd();
  }
}

export const debugger = LanguageDebugger.getInstance();
```

## 性能优化

### 1. 编译缓存

```typescript
// 编译缓存管理
class CompilationCache {
  private cache = new Map<string, CacheEntry>();
  private maxSize = 100;
  private ttl = 5 * 60 * 1000; // 5 分钟

  private generateKey(language: Language, code: string, options: any): string {
    const optionsHash = this.hashObject(options);
    const codeHash = this.hashString(code);
    return `${language}:${codeHash}:${optionsHash}`;
  }

  get(language: Language, code: string, options: any): CompileResult | null {
    const key = this.generateKey(language, code, options);
    const entry = this.cache.get(key);

    if (!entry) return null;

    // 检查是否过期
    if (Date.now() - entry.timestamp > this.ttl) {
      this.cache.delete(key);
      return null;
    }

    return entry.result;
  }

  set(language: Language, code: string, options: any, result: CompileResult): void {
    const key = this.generateKey(language, code, options);

    // 清理过期条目
    this.cleanup();

    // 如果缓存已满，删除最旧的条目
    if (this.cache.size >= this.maxSize) {
      const oldestKey = this.cache.keys().next().value;
      this.cache.delete(oldestKey);
    }

    this.cache.set(key, {
      result,
      timestamp: Date.now(),
    });
  }

  private cleanup(): void {
    const now = Date.now();
    for (const [key, entry] of this.cache.entries()) {
      if (now - entry.timestamp > this.ttl) {
        this.cache.delete(key);
      }
    }
  }

  private hashString(str: string): string {
    let hash = 0;
    for (let i = 0; i < str.length; i++) {
      const char = str.charCodeAt(i);
      hash = ((hash << 5) - hash) + char;
      hash = hash & hash; // 转换为 32 位整数
    }
    return hash.toString(36);
  }

  private hashObject(obj: any): string {
    return this.hashString(JSON.stringify(obj));
  }
}

interface CacheEntry {
  result: CompileResult;
  timestamp: number;
}

export const compilationCache = new CompilationCache();
```

### 2. 懒加载策略

```typescript
// 懒加载管理器
class LazyLoadManager {
  private loadPromises = new Map<Language, Promise<void>>();
  private preloadQueue: Language[] = [];
  private isPreloading = false;

  // 按需加载语言
  async loadOnDemand(language: Language, config: Config): Promise<void> {
    if (this.loadPromises.has(language)) {
      return this.loadPromises.get(language);
    }

    const loadPromise = languageLoader.loadLanguage(language, config);
    this.loadPromises.set(language, loadPromise);

    return loadPromise;
  }

  // 预加载热门语言
  preloadPopularLanguages(): void {
    const popularLanguages: Language[] = [
      'javascript', 'typescript', 'html', 'css', 'markdown',
      'jsx', 'tsx', 'vue', 'react', 'svelte'
    ];

    this.preloadQueue.push(...popularLanguages);
    this.startPreloading();
  }

  private async startPreloading(): Promise<void> {
    if (this.isPreloading || this.preloadQueue.length === 0) return;

    this.isPreloading = true;

    while (this.preloadQueue.length > 0) {
      const language = this.preloadQueue.shift()!;

      try {
        await this.loadOnDemand(language, getDefaultConfig());
        console.log(`Preloaded language: ${language}`);
      } catch (error) {
        console.warn(`Failed to preload language: ${language}`, error);
      }

      // 避免阻塞主线程
      await new Promise(resolve => setTimeout(resolve, 100));
    }

    this.isPreloading = false;
  }
}

export const lazyLoadManager = new LazyLoadManager();
```

## 总结

LiveCodes 的语言支持机制通过以下关键设计实现了对 90+ 种语言的支持：

### 核心特性
1. **统一接口规范**：所有语言遵循 `LanguageSpecs` 接口
2. **模块化架构**：每种语言独立实现，易于维护和扩展
3. **智能加载**：懒加载和预加载相结合的策略
4. **灵活配置**：支持自定义编译选项和处理器
5. **强大缓存**：多层缓存机制提高性能

### 技术优势
1. **可扩展性**：添加新语言只需实现接口规范
2. **性能优化**：缓存、懒加载、Web Workers 等优化策略
3. **错误处理**：完善的错误处理和调试工具
4. **类型安全**：完整的 TypeScript 类型定义

### 支持范围
1. **传统语言**：JavaScript、TypeScript、Python、Ruby 等
2. **现代框架**：React、Vue、Svelte、Solid 等
3. **WebAssembly**：通过 WASM 支持更多语言
4. **模板语言**：各种模板引擎和标记语言
5. **样式语言**：CSS 预处理器和后处理器

这种设计使得 LiveCodes 能够在浏览器中提供接近本地开发环境的多语言支持体验。
```
