# LiveCodes è¯­è¨€æ”¯æŒæœºåˆ¶è¯¦è§£

## æ¦‚è¿°

LiveCodes æ”¯æŒ 90+ ç§ç¼–ç¨‹è¯­è¨€å’Œæ¡†æ¶ï¼Œè¿™å¾—ç›Šäºå…¶çµæ´»çš„è¯­è¨€æ”¯æŒæœºåˆ¶ã€‚è¯¥æœºåˆ¶é€šè¿‡ç»Ÿä¸€çš„æ¥å£è§„èŒƒã€æ¨¡å—åŒ–çš„ç¼–è¯‘å™¨æ¶æ„å’Œæ™ºèƒ½çš„åŠ è½½ç­–ç•¥ï¼Œå®ç°äº†å¯¹å¤šç§è¯­è¨€çš„æ— ç¼æ”¯æŒã€‚

## è¯­è¨€åˆ†ç±»ä½“ç³»

### 1. æŒ‰ç¼–è¾‘å™¨åˆ†ç±»

LiveCodes å°†è¯­è¨€æŒ‰ç…§ç”¨é€”åˆ†ä¸ºä¸‰ä¸ªç¼–è¾‘å™¨ï¼š

```typescript
export type EditorId = 'markup' | 'style' | 'script';

// æ ‡è®°è¯­è¨€ (markup)
const markupLanguages = [
  'html', 'markdown', 'mdx', 'pug', 'haml', 'mustache', 
  'handlebars', 'ejs', 'nunjucks', 'liquid', 'asciidoc',
  'bbcode', 'dot', 'twig', 'vento', 'art-template', 'jinja'
];

// æ ·å¼è¯­è¨€ (style)  
const styleLanguages = [
  'css', 'scss', 'sass', 'less', 'stylus', 'postcss',
  'tailwindcss', 'windicss', 'unocss', 'lightningcss', 'stylis'
];

// è„šæœ¬è¯­è¨€ (script)
const scriptLanguages = [
  'javascript', 'typescript', 'jsx', 'tsx', 'coffeescript',
  'livescript', 'python', 'python-wasm', 'ruby', 'ruby-wasm',
  'php', 'php-wasm', 'go', 'rust', 'cpp', 'cpp-wasm',
  'csharp-wasm', 'java', 'kotlin', 'scala', 'clojure',
  'clojurescript', 'reason', 'rescript', 'ocaml', 'fsharp',
  'elm', 'purescript', 'haskell', 'scheme', 'racket',
  'lua', 'lua-wasm', 'perl', 'r', 'julia', 'dart',
  'assemblyscript', 'wat', 'gleam', 'civet', 'imba',
  'solid', 'solid.tsx', 'svelte', 'vue', 'vue2', 'react',
  'react.tsx', 'react-native', 'react-native.tsx', 'stencil',
  'lit', 'riot', 'malina', 'astro', 'blockly', 'prolog',
  'tcl', 'fennel', 'teal', 'commonlisp', 'clio'
];
```

### 2. æŒ‰æ‰§è¡Œæ–¹å¼åˆ†ç±»

#### A. å®¢æˆ·ç«¯ç¼–è¯‘è¯­è¨€
ç›´æ¥åœ¨æµè§ˆå™¨ä¸­ç¼–è¯‘æ‰§è¡Œï¼š

```typescript
// TypeScript/JavaScript ç³»åˆ—
const clientCompiledLanguages = [
  'typescript', 'jsx', 'tsx', 'coffeescript', 'livescript',
  'babel', 'sucrase', 'flow'
];

// CSS é¢„å¤„ç†å™¨
const cssPreprocessors = [
  'scss', 'sass', 'less', 'stylus', 'postcss'
];

// æ¨¡æ¿è¯­è¨€
const templateLanguages = [
  'pug', 'haml', 'mustache', 'handlebars', 'ejs',
  'nunjucks', 'liquid', 'twig', 'eta'
];
```

#### B. WebAssembly è¯­è¨€
é€šè¿‡ WebAssembly è¿è¡Œæ—¶æ‰§è¡Œï¼š

```typescript
const wasmLanguages = [
  'python-wasm',    // Pyodide
  'ruby-wasm',      // ruby.wasm
  'php-wasm',       // php-wasm
  'lua-wasm',       // Wasmoon
  'cpp-wasm',       // Emscripten
  'csharp-wasm',    // Blazor
  'assemblyscript', // AssemblyScript
  'wat',            // WebAssembly Text Format
];
```

#### C. æ¡†æ¶ç‰¹å®šè¯­è¨€
éœ€è¦ç‰¹å®šæ¡†æ¶æ”¯æŒçš„è¯­è¨€ï¼š

```typescript
const frameworkLanguages = [
  'vue',            // Vue.js SFC
  'svelte',         // Svelte ç»„ä»¶
  'solid',          // Solid.js
  'react',          // React JSX
  'stencil',        // Stencil ç»„ä»¶
  'lit',            // Lit å…ƒç´ 
  'astro',          // Astro ç»„ä»¶
];
```

## è¯­è¨€å®šä¹‰è§„èŒƒ

### 1. LanguageSpecs æ¥å£

æ¯ç§è¯­è¨€éƒ½å¿…é¡»å®ç° `LanguageSpecs` æ¥å£ï¼š

```typescript
export interface LanguageSpecs {
  name: Language;                    // è¯­è¨€æ ‡è¯†ç¬¦
  title: string;                     // çŸ­æ ‡é¢˜
  longTitle?: string;                // å®Œæ•´æ ‡é¢˜
  info?: boolean;                    // æ˜¯å¦æ˜¾ç¤ºä¿¡æ¯æŒ‰é’®
  parser?: Parser;                   // ä»£ç è§£æå™¨é…ç½®
  formatter?: LanguageFormatter;     // ä»£ç æ ¼å¼åŒ–å™¨
  compiler: Compiler | Language;     // ç¼–è¯‘å™¨é…ç½®
  extensions: Language[];            // æ–‡ä»¶æ‰©å±•å
  editor: EditorId;                  // æ‰€å±ç¼–è¾‘å™¨
  editorLanguage?: Language;         // ç¼–è¾‘å™¨è¯­è¨€ï¼ˆè¯­æ³•é«˜äº®ï¼‰
  preset?: CssPresetId;             // CSS é¢„è®¾
  largeDownload?: boolean;           // å¤§å‹ä¸‹è½½æ ‡è®°
}
```

### 2. ç¼–è¯‘å™¨é…ç½®ç±»å‹

```typescript
export interface Compiler {
  url?: string;                      // ç¼–è¯‘å™¨è„šæœ¬ URL
  factory?: CompilerFactory;         // ç¼–è¯‘å™¨å·¥å‚å‡½æ•°
  scripts?: ScriptLoader;            // è¿è¡Œæ—¶è„šæœ¬
  scriptType?: string;               // è„šæœ¬ç±»å‹
  compiledCodeLanguage?: Language;   // ç¼–è¯‘åè¯­è¨€
  inlineModule?: string;             // å†…è”æ¨¡å—ä»£ç 
  loadAsExternalModule?: boolean;    // ä½œä¸ºå¤–éƒ¨æ¨¡å—åŠ è½½
  types?: Types;                     // TypeScript ç±»å‹å®šä¹‰
}

export interface CompilerFactory {
  (config: Config, baseUrl: string): Promise<CompilerFunction> | CompilerFunction;
}

export interface CompilerFunction {
  (code: string, options: CompileOptions): Promise<string | CompileResult>;
}
```

## å…·ä½“è¯­è¨€å®ç°æ¡ˆä¾‹

### 1. TypeScript å®ç°

TypeScript æ˜¯æœ€åŸºç¡€çš„ç¼–è¯‘è¯­è¨€ä¹‹ä¸€ï¼š

```typescript
import { typescriptUrl } from '../../vendors';
import { getLanguageCustomSettings } from '../../utils';
import { hasCustomJsxRuntime } from '../jsx/utils';

export const typescript: LanguageSpecs = {
  name: 'typescript',
  title: 'TS',
  longTitle: 'TypeScript',
  parser: {
    name: 'babel-ts',
    pluginUrls: [parserPlugins.babel, parserPlugins.html],
  },
  compiler: {
    url: typescriptUrl,
    factory: () => async (code, { config }) => {
      const options = {
        target: 'ES2020',
        module: 'ESNext',
        moduleResolution: 'node',
        allowSyntheticDefaultImports: true,
        esModuleInterop: true,
        skipLibCheck: true,
        ...(['jsx', 'tsx'].includes(config.script.language) && !hasCustomJsxRuntime(code, config)
          ? { jsx: 'react-jsx' }
          : {}),
        ...getLanguageCustomSettings('typescript', config),
        ...getLanguageCustomSettings(config.script.language, config),
      };
      
      return (window as any).ts.transpile(code, options);
    },
  },
  extensions: ['ts', 'typescript'],
  editor: 'script',
};
```

### 2. Vue.js å•æ–‡ä»¶ç»„ä»¶

Vue SFC éœ€è¦å¤æ‚çš„ç¼–è¯‘å¤„ç†ï¼š

```typescript
export const vue: LanguageSpecs = {
  name: 'vue',
  title: 'Vue 3 SFC',
  compiler: {
    factory: (_config, baseUrl) => {
      (self as any).importScripts(baseUrl + '{{hash:lang-vue-compiler.js}}');
      return (self as any).createVueCompiler();
    },
  },
  extensions: ['vue'],
  editor: 'script',
};

// Vue ç¼–è¯‘å™¨å®ç° (lang-vue-compiler.ts)
(self as any).createVueCompiler = (): CompilerFunction => {
  const { compile, compileScript, compileTemplate, compileStyle } = (self as any).VueCompiler;
  
  return async (code, { config }) => {
    try {
      // è§£æ SFC
      const { descriptor, errors } = compile(code, { filename: 'component.vue' });
      
      if (errors.length > 0) {
        console.error('Vue SFC parse errors:', errors);
      }
      
      let scriptContent = '';
      let templateContent = '';
      let stylesContent = '';
      
      // ç¼–è¯‘è„šæœ¬éƒ¨åˆ†
      if (descriptor.script || descriptor.scriptSetup) {
        const scriptResult = compileScript(descriptor, {
          id: 'component',
          inlineTemplate: !descriptor.template,
          templateOptions: {
            compilerOptions: {
              mode: 'module',
            },
          },
          ...getLanguageCustomSettings('vue', config),
        });
        scriptContent = scriptResult.content;
      }
      
      // ç¼–è¯‘æ¨¡æ¿éƒ¨åˆ†
      if (descriptor.template && !descriptor.scriptSetup) {
        const templateResult = compileTemplate({
          source: descriptor.template.content,
          id: 'component',
          filename: 'component.vue',
          compilerOptions: {
            mode: 'module',
          },
        });
        templateContent = templateResult.code;
      }
      
      // ç¼–è¯‘æ ·å¼éƒ¨åˆ†
      if (descriptor.styles.length > 0) {
        const stylePromises = descriptor.styles.map(async (style, index) => {
          const styleResult = compileStyle({
            source: style.content,
            id: `component-${index}`,
            filename: 'component.vue',
            scoped: style.scoped,
            modules: style.module,
          });
          return styleResult.code;
        });
        
        const styleResults = await Promise.all(stylePromises);
        stylesContent = styleResults.join('\n');
      }
      
      // ç»„åˆæœ€ç»ˆä»£ç 
      return generateVueComponent(scriptContent, templateContent, stylesContent);
      
    } catch (error) {
      console.error('Vue compilation error:', error);
      return `console.error('Vue compilation failed: ${error.message}');`;
    }
  };
};

// ç”Ÿæˆæœ€ç»ˆçš„ Vue ç»„ä»¶ä»£ç 
const generateVueComponent = (
  script: string,
  template: string,
  styles: string
): string => {
  return `
// Vue 3 Component
${script}

// æ³¨å…¥æ ·å¼
if (typeof document !== 'undefined') {
  const style = document.createElement('style');
  style.textContent = \`${styles}\`;
  document.head.appendChild(style);
}

// å¯¼å‡ºç»„ä»¶
export default component;
`.trim();
};
```

### 3. Python (Pyodide) å®ç°

Python é€šè¿‡ Pyodide åœ¨ WebAssembly ä¸­è¿è¡Œï¼š

```typescript
export const pythonWasm: LanguageSpecs = {
  name: 'python-wasm',
  title: 'Python (Wasm)',
  compiler: {
    factory: () => async (code) => code, // Python ä»£ç ä¸éœ€è¦ç¼–è¯‘
    scripts: ({ baseUrl }) => [
      baseUrl + 'pyodide/pyodide.js',
    ],
    scriptType: 'text/python-wasm',
    compiledCodeLanguage: 'python',
    inlineModule: `
      // åˆå§‹åŒ– Pyodide
      let pyodideReady = false;
      
      async function initPyodide() {
        if (pyodideReady) return;
        
        try {
          self.pyodide = await loadPyodide({
            indexURL: '${baseUrl}pyodide/',
          });
          
          // é¢„åŠ è½½å¸¸ç”¨åŒ…
          await self.pyodide.loadPackage([
            'numpy', 'pandas', 'matplotlib', 'scipy'
          ]);
          
          // è®¾ç½®è¾“å‡ºé‡å®šå‘
          self.pyodide.runPython(\`
import sys
import io
from contextlib import redirect_stdout, redirect_stderr

class ConsoleCapture:
    def __init__(self):
        self.output = []
    
    def write(self, text):
        if text.strip():
            self.output.append(text.strip())
            console.log(text.strip())
    
    def flush(self):
        pass

console_capture = ConsoleCapture()
          \`);
          
          pyodideReady = true;
          console.log('Pyodide initialized successfully');
        } catch (error) {
          console.error('Failed to initialize Pyodide:', error);
        }
      }
      
      // æ‰§è¡Œ Python ä»£ç 
      async function runPython(code) {
        await initPyodide();
        
        try {
          self.pyodide.runPython(\`
sys.stdout = console_capture
sys.stderr = console_capture
console_capture.output = []
          \`);
          
          // æ‰§è¡Œç”¨æˆ·ä»£ç 
          const result = self.pyodide.runPython(code);
          
          // å¦‚æœæœ‰è¿”å›å€¼ï¼Œæ˜¾ç¤ºå®ƒ
          if (result !== undefined && result !== null) {
            console.log(result);
          }
          
        } catch (error) {
          console.error('Python execution error:', error.message);
        }
      }
      
      // è‡ªåŠ¨åˆå§‹åŒ–
      initPyodide();
    `,
  },
  extensions: ['py'],
  editor: 'script',
  largeDownload: true,
};
```

### 4. Svelte ç»„ä»¶å®ç°

Svelte éœ€è¦ç‰¹æ®Šçš„ç¼–è¯‘å¤„ç†ï¼š

```typescript
export const svelte: LanguageSpecs = {
  name: 'svelte',
  title: 'Svelte',
  compiler: {
    factory: (_config, baseUrl) => {
      (self as any).importScripts(baseUrl + '{{hash:lang-svelte-compiler.js}}');
      return (self as any).createSvelteCompiler();
    },
  },
  extensions: ['svelte'],
  editor: 'script',
};

// Svelte ç¼–è¯‘å™¨å®ç°
(self as any).createSvelteCompiler = (): CompilerFunction => {
  const { compile } = (self as any).svelte;
  
  return async (code, { config }) => {
    try {
      const options = {
        generate: 'dom',
        hydratable: true,
        dev: false,
        css: 'injected',
        ...getLanguageCustomSettings('svelte', config),
      };
      
      const result = compile(code, options);
      
      if (result.warnings.length > 0) {
        result.warnings.forEach(warning => {
          console.warn('Svelte warning:', warning.message);
        });
      }
      
      // ç”Ÿæˆæœ€ç»ˆä»£ç 
      return `
// Svelte Component
${result.js.code}

// å¯¼å‡ºç»„ä»¶ç±»
export default Component;
      `.trim();
      
    } catch (error) {
      console.error('Svelte compilation error:', error);
      return `console.error('Svelte compilation failed: ${error.message}');`;
    }
  };
};
```

## è¯­è¨€æ³¨å†Œå’Œç®¡ç†

### 1. è¯­è¨€æ³¨å†Œç³»ç»Ÿ

æ‰€æœ‰è¯­è¨€é€šè¿‡ç»Ÿä¸€çš„æ³¨å†Œç³»ç»Ÿç®¡ç†ï¼š

```typescript
// src/livecodes/languages/languages.ts
import { html } from './html';
import { css } from './css';
import { javascript } from './javascript';
import { typescript } from './typescript';
// ... å¯¼å…¥æ‰€æœ‰è¯­è¨€

export const languages: LanguageSpecs[] = [
  // æ ‡è®°è¯­è¨€
  html,
  markdown,
  mdx,
  pug,
  haml,
  // ... æ›´å¤šæ ‡è®°è¯­è¨€

  // æ ·å¼è¯­è¨€
  css,
  scss,
  sass,
  less,
  // ... æ›´å¤šæ ·å¼è¯­è¨€

  // è„šæœ¬è¯­è¨€
  javascript,
  typescript,
  jsx,
  tsx,
  // ... æ›´å¤šè„šæœ¬è¯­è¨€
];

// è¯­è¨€æ˜ å°„è¡¨
const languageMap = new Map<Language, LanguageSpecs>();
const extensionMap = new Map<string, Language>();
const aliasMap = new Map<string, Language>();

// åˆå§‹åŒ–æ˜ å°„è¡¨
const initializeLanguageMaps = () => {
  languages.forEach(lang => {
    languageMap.set(lang.name, lang);

    // æ‰©å±•åæ˜ å°„
    lang.extensions.forEach(ext => {
      extensionMap.set(ext, lang.name);
    });

    // åˆ«åæ˜ å°„
    if (lang.title !== lang.name) {
      aliasMap.set(lang.title.toLowerCase(), lang.name);
    }
    if (lang.longTitle) {
      aliasMap.set(lang.longTitle.toLowerCase(), lang.name);
    }
  });
};

initializeLanguageMaps();
```

### 2. è¯­è¨€æŸ¥è¯¢å·¥å…·

```typescript
// æ ¹æ®åç§°è·å–è¯­è¨€è§„èŒƒ
export const getLanguageSpecs = (language: Language): LanguageSpecs | undefined => {
  return languageMap.get(language);
};

// æ ¹æ®æ‰©å±•åè·å–è¯­è¨€
export const getLanguageByExtension = (extension: string): Language | undefined => {
  return extensionMap.get(extension.toLowerCase());
};

// æ ¹æ®åˆ«åè·å–è¯­è¨€
export const getLanguageByAlias = (alias: string): Language | undefined => {
  const normalized = alias.toLowerCase().trim();
  return aliasMap.get(normalized) || (languageMap.has(normalized as Language) ? normalized as Language : undefined);
};

// è·å–è¯­è¨€æ ‡é¢˜
export const getLanguageTitle = (language: Language): string => {
  const specs = getLanguageSpecs(language);
  return specs?.longTitle || specs?.title || language;
};

// è·å–ç¼–è¾‘å™¨è¯­è¨€ï¼ˆç”¨äºè¯­æ³•é«˜äº®ï¼‰
export const getLanguageEditorId = (language: Language): Language => {
  const specs = getLanguageSpecs(language);
  return specs?.editorLanguage || language;
};

// æ£€æŸ¥è¯­è¨€æ˜¯å¦å¯ç”¨
export const languageIsEnabled = (language: Language, config: Config): boolean => {
  const disabledLanguages = config.customSettings?.disabledLanguages || [];
  return !disabledLanguages.includes(language);
};
```

### 3. åŠ¨æ€è¯­è¨€åŠ è½½

```typescript
// è¯­è¨€ç¼–è¯‘å™¨åŠ è½½å™¨
class LanguageLoader {
  private loadedCompilers = new Set<Language>();
  private loadingPromises = new Map<Language, Promise<void>>();

  async loadLanguage(language: Language, config: Config): Promise<void> {
    // æ£€æŸ¥æ˜¯å¦å·²åŠ è½½
    if (this.loadedCompilers.has(language)) {
      return;
    }

    // æ£€æŸ¥æ˜¯å¦æ­£åœ¨åŠ è½½
    if (this.loadingPromises.has(language)) {
      return this.loadingPromises.get(language);
    }

    // å¼€å§‹åŠ è½½
    const loadPromise = this.doLoadLanguage(language, config);
    this.loadingPromises.set(language, loadPromise);

    try {
      await loadPromise;
      this.loadedCompilers.add(language);
    } finally {
      this.loadingPromises.delete(language);
    }
  }

  private async doLoadLanguage(language: Language, config: Config): Promise<void> {
    const specs = getLanguageSpecs(language);
    if (!specs?.compiler) {
      throw new Error(`No compiler found for language: ${language}`);
    }

    if (typeof specs.compiler === 'string') {
      // å¼•ç”¨å…¶ä»–è¯­è¨€çš„ç¼–è¯‘å™¨
      return this.loadLanguage(specs.compiler, config);
    }

    const compiler = specs.compiler;

    // åŠ è½½ç¼–è¯‘å™¨è„šæœ¬
    if (compiler.url) {
      await this.loadScript(compiler.url);
    }

    // åˆ›å»ºç¼–è¯‘å™¨å®ä¾‹
    if (compiler.factory) {
      const compilerFn = await compiler.factory(config, getBaseUrl());
      registerCompiler(language, compilerFn, specs);
    }
  }

  private async loadScript(url: string): Promise<void> {
    return new Promise((resolve, reject) => {
      const script = document.createElement('script');
      script.src = url;
      script.onload = () => resolve();
      script.onerror = () => reject(new Error(`Failed to load script: ${url}`));
      document.head.appendChild(script);
    });
  }
}

export const languageLoader = new LanguageLoader();
```

## å¤„ç†å™¨ç³»ç»Ÿ

### 1. CSS å¤„ç†å™¨

CSS å¤„ç†å™¨ç”¨äºåå¤„ç† CSS ä»£ç ï¼š

```typescript
// CSS å¤„ç†å™¨å®šä¹‰
export const processors: ProcessorSpecs[] = [
  {
    name: 'postcss',
    title: 'PostCSS',
    isPostcssPlugin: true,
    compiler: {
      url: postcssUrl,
      factory: () => async (code, { config }) => {
        const postcss = (window as any).postcss;
        const plugins = getPostcssPlugins(config);

        const result = await postcss(plugins).process(code, {
          from: undefined,
          to: undefined,
        });

        return result.css;
      },
    },
  },
  {
    name: 'autoprefixer',
    title: 'Autoprefixer',
    isPostcssPlugin: true,
    compiler: {
      url: autoprefixerUrl,
      factory: () => async (code) => {
        const postcss = (window as any).postcss;
        const autoprefixer = (window as any).autoprefixer;

        const result = await postcss([autoprefixer]).process(code, {
          from: undefined,
          to: undefined,
        });

        return result.css;
      },
    },
  },
];

// è·å–æ¿€æ´»çš„å¤„ç†å™¨
export const getActivatedProcessors = (language: Language, config: Config): string => {
  const specs = getLanguageSpecs(language);
  if (!specs || specs.editor !== 'style') return '';

  const processors = config.processors || [];
  const activated = processors.filter(p => p.enabled).map(p => p.name);

  return JSON.stringify(activated.sort());
};
```

### 2. JavaScript å¤„ç†å™¨

JavaScript å¤„ç†å™¨ç”¨äºè½¬æ¢ JavaScript ä»£ç ï¼š

```typescript
// Babel å¤„ç†å™¨
export const babel: ProcessorSpecs = {
  name: 'babel',
  title: 'Babel',
  compiler: {
    url: babelUrl,
    factory: () => async (code, { config }) => {
      const Babel = (window as any).Babel;
      const options = {
        presets: ['env'],
        plugins: [],
        ...getLanguageCustomSettings('babel', config),
      };

      const result = Babel.transform(code, options);
      return result.code;
    },
  },
};

// TypeScript å¤„ç†å™¨
export const typescript: ProcessorSpecs = {
  name: 'typescript',
  title: 'TypeScript',
  compiler: {
    url: typescriptUrl,
    factory: () => async (code, { config }) => {
      const ts = (window as any).ts;
      const options = {
        target: ts.ScriptTarget.ES2020,
        module: ts.ModuleKind.ESNext,
        ...getLanguageCustomSettings('typescript', config),
      };

      return ts.transpile(code, options);
    },
  },
};
```

## è‡ªå®šä¹‰è®¾ç½®ç³»ç»Ÿ

### 1. è¯­è¨€è‡ªå®šä¹‰è®¾ç½®

æ¯ç§è¯­è¨€éƒ½å¯ä»¥æœ‰è‡ªå®šä¹‰çš„ç¼–è¯‘é€‰é¡¹ï¼š

```typescript
// è·å–è¯­è¨€è‡ªå®šä¹‰è®¾ç½®
export const getLanguageCustomSettings = (language: Language, config: Config): any => {
  const customSettings = config.customSettings || {};
  return customSettings[language] || {};
};

// è®¾ç½®è¯­è¨€è‡ªå®šä¹‰è®¾ç½®
export const setLanguageCustomSettings = (
  language: Language,
  settings: any,
  config: Config
): Config => {
  return {
    ...config,
    customSettings: {
      ...config.customSettings,
      [language]: {
        ...getLanguageCustomSettings(language, config),
        ...settings,
      },
    },
  };
};

// å¸¸è§çš„è‡ªå®šä¹‰è®¾ç½®ç¤ºä¾‹
const commonCustomSettings = {
  typescript: {
    target: 'ES2020',
    module: 'ESNext',
    strict: true,
    experimentalDecorators: false,
    emitDecoratorMetadata: false,
  },
  babel: {
    presets: [['env', { modules: false }]],
    plugins: [],
  },
  postcss: {
    plugins: ['autoprefixer', 'cssnano'],
  },
  python: {
    autoloadStdlib: true,
    packages: ['numpy', 'pandas'],
  },
  vue: {
    compilerOptions: {
      mode: 'module',
    },
  },
};
```

### 2. ç¼–è¯‘é€‰é¡¹ç®¡ç†

```typescript
// ç¼–è¯‘é€‰é¡¹æ¥å£
export interface CompileOptions {
  forceCompile?: boolean;        // å¼ºåˆ¶é‡æ–°ç¼–è¯‘
  sourceMap?: boolean;           // ç”Ÿæˆæºæ˜ å°„
  minify?: boolean;              // å‹ç¼©ä»£ç 
  target?: string;               // ç¼–è¯‘ç›®æ ‡
  format?: 'esm' | 'cjs' | 'iife'; // è¾“å‡ºæ ¼å¼
  external?: string[];           // å¤–éƒ¨ä¾èµ–
}

// è·å–ç¼–è¯‘é€‰é¡¹
const getCompileOptions = (language: Language, config: Config): CompileOptions => {
  const customSettings = getLanguageCustomSettings(language, config);
  const globalOptions = config.compileOptions || {};

  return {
    ...globalOptions,
    ...customSettings.compileOptions,
  };
};
```

## é”™è¯¯å¤„ç†å’Œè°ƒè¯•

### 1. ç¼–è¯‘é”™è¯¯å¤„ç†

```typescript
// ç¼–è¯‘é”™è¯¯ç±»å‹
export interface CompileError {
  message: string;
  line?: number;
  column?: number;
  filename?: string;
  stack?: string;
}

// é”™è¯¯å¤„ç†å™¨
export const handleCompileError = (
  error: Error,
  language: Language,
  code: string
): CompileResult => {
  const compileError: CompileError = {
    message: error.message,
    stack: error.stack,
  };

  // å°è¯•è§£æé”™è¯¯ä½ç½®
  const location = parseErrorLocation(error.message);
  if (location) {
    compileError.line = location.line;
    compileError.column = location.column;
  }

  // è®°å½•é”™è¯¯
  console.error(`Compilation failed for ${language}:`, compileError);

  // å‘é€é”™è¯¯æŠ¥å‘Š
  if (process.env.NODE_ENV === 'production') {
    sendErrorReport({
      type: 'compile_error',
      language,
      error: compileError,
      codeLength: code.length,
    });
  }

  return {
    code: '',
    info: {
      error: compileError,
    },
  };
};

// è§£æé”™è¯¯ä½ç½®
const parseErrorLocation = (message: string): { line: number; column: number } | null => {
  // TypeScript é”™è¯¯æ ¼å¼: "error TS2304: Cannot find name 'foo' at line 5, column 10"
  const tsMatch = message.match(/at line (\d+), column (\d+)/);
  if (tsMatch) {
    return {
      line: parseInt(tsMatch[1], 10),
      column: parseInt(tsMatch[2], 10),
    };
  }

  // Babel é”™è¯¯æ ¼å¼: "SyntaxError: Unexpected token (5:10)"
  const babelMatch = message.match(/\((\d+):(\d+)\)/);
  if (babelMatch) {
    return {
      line: parseInt(babelMatch[1], 10),
      column: parseInt(babelMatch[2], 10),
    };
  }

  return null;
};
```

### 2. è°ƒè¯•å·¥å…·

```typescript
// è¯­è¨€è°ƒè¯•å™¨
export class LanguageDebugger {
  private static instance: LanguageDebugger;
  private debugMode = false;

  static getInstance(): LanguageDebugger {
    if (!this.instance) {
      this.instance = new LanguageDebugger();
    }
    return this.instance;
  }

  setDebugMode(enabled: boolean): void {
    this.debugMode = enabled;
  }

  logCompilation(language: Language, code: string, result: CompileResult): void {
    if (!this.debugMode) return;

    console.group(`ğŸ”§ Compilation: ${language}`);
    console.log('Input code:', code);
    console.log('Output code:', result.code);
    console.log('Compilation info:', result.info);
    console.groupEnd();
  }

  logError(language: Language, error: Error): void {
    if (!this.debugMode) return;

    console.group(`âŒ Compilation Error: ${language}`);
    console.error('Error:', error);
    console.trace();
    console.groupEnd();
  }
}

export const debugger = LanguageDebugger.getInstance();
```

## æ€§èƒ½ä¼˜åŒ–

### 1. ç¼–è¯‘ç¼“å­˜

```typescript
// ç¼–è¯‘ç¼“å­˜ç®¡ç†
class CompilationCache {
  private cache = new Map<string, CacheEntry>();
  private maxSize = 100;
  private ttl = 5 * 60 * 1000; // 5 åˆ†é’Ÿ

  private generateKey(language: Language, code: string, options: any): string {
    const optionsHash = this.hashObject(options);
    const codeHash = this.hashString(code);
    return `${language}:${codeHash}:${optionsHash}`;
  }

  get(language: Language, code: string, options: any): CompileResult | null {
    const key = this.generateKey(language, code, options);
    const entry = this.cache.get(key);

    if (!entry) return null;

    // æ£€æŸ¥æ˜¯å¦è¿‡æœŸ
    if (Date.now() - entry.timestamp > this.ttl) {
      this.cache.delete(key);
      return null;
    }

    return entry.result;
  }

  set(language: Language, code: string, options: any, result: CompileResult): void {
    const key = this.generateKey(language, code, options);

    // æ¸…ç†è¿‡æœŸæ¡ç›®
    this.cleanup();

    // å¦‚æœç¼“å­˜å·²æ»¡ï¼Œåˆ é™¤æœ€æ—§çš„æ¡ç›®
    if (this.cache.size >= this.maxSize) {
      const oldestKey = this.cache.keys().next().value;
      this.cache.delete(oldestKey);
    }

    this.cache.set(key, {
      result,
      timestamp: Date.now(),
    });
  }

  private cleanup(): void {
    const now = Date.now();
    for (const [key, entry] of this.cache.entries()) {
      if (now - entry.timestamp > this.ttl) {
        this.cache.delete(key);
      }
    }
  }

  private hashString(str: string): string {
    let hash = 0;
    for (let i = 0; i < str.length; i++) {
      const char = str.charCodeAt(i);
      hash = ((hash << 5) - hash) + char;
      hash = hash & hash; // è½¬æ¢ä¸º 32 ä½æ•´æ•°
    }
    return hash.toString(36);
  }

  private hashObject(obj: any): string {
    return this.hashString(JSON.stringify(obj));
  }
}

interface CacheEntry {
  result: CompileResult;
  timestamp: number;
}

export const compilationCache = new CompilationCache();
```

### 2. æ‡’åŠ è½½ç­–ç•¥

```typescript
// æ‡’åŠ è½½ç®¡ç†å™¨
class LazyLoadManager {
  private loadPromises = new Map<Language, Promise<void>>();
  private preloadQueue: Language[] = [];
  private isPreloading = false;

  // æŒ‰éœ€åŠ è½½è¯­è¨€
  async loadOnDemand(language: Language, config: Config): Promise<void> {
    if (this.loadPromises.has(language)) {
      return this.loadPromises.get(language);
    }

    const loadPromise = languageLoader.loadLanguage(language, config);
    this.loadPromises.set(language, loadPromise);

    return loadPromise;
  }

  // é¢„åŠ è½½çƒ­é—¨è¯­è¨€
  preloadPopularLanguages(): void {
    const popularLanguages: Language[] = [
      'javascript', 'typescript', 'html', 'css', 'markdown',
      'jsx', 'tsx', 'vue', 'react', 'svelte'
    ];

    this.preloadQueue.push(...popularLanguages);
    this.startPreloading();
  }

  private async startPreloading(): Promise<void> {
    if (this.isPreloading || this.preloadQueue.length === 0) return;

    this.isPreloading = true;

    while (this.preloadQueue.length > 0) {
      const language = this.preloadQueue.shift()!;

      try {
        await this.loadOnDemand(language, getDefaultConfig());
        console.log(`Preloaded language: ${language}`);
      } catch (error) {
        console.warn(`Failed to preload language: ${language}`, error);
      }

      // é¿å…é˜»å¡ä¸»çº¿ç¨‹
      await new Promise(resolve => setTimeout(resolve, 100));
    }

    this.isPreloading = false;
  }
}

export const lazyLoadManager = new LazyLoadManager();
```

## æ€»ç»“

LiveCodes çš„è¯­è¨€æ”¯æŒæœºåˆ¶é€šè¿‡ä»¥ä¸‹å…³é”®è®¾è®¡å®ç°äº†å¯¹ 90+ ç§è¯­è¨€çš„æ”¯æŒï¼š

### æ ¸å¿ƒç‰¹æ€§
1. **ç»Ÿä¸€æ¥å£è§„èŒƒ**ï¼šæ‰€æœ‰è¯­è¨€éµå¾ª `LanguageSpecs` æ¥å£
2. **æ¨¡å—åŒ–æ¶æ„**ï¼šæ¯ç§è¯­è¨€ç‹¬ç«‹å®ç°ï¼Œæ˜“äºç»´æŠ¤å’Œæ‰©å±•
3. **æ™ºèƒ½åŠ è½½**ï¼šæ‡’åŠ è½½å’Œé¢„åŠ è½½ç›¸ç»“åˆçš„ç­–ç•¥
4. **çµæ´»é…ç½®**ï¼šæ”¯æŒè‡ªå®šä¹‰ç¼–è¯‘é€‰é¡¹å’Œå¤„ç†å™¨
5. **å¼ºå¤§ç¼“å­˜**ï¼šå¤šå±‚ç¼“å­˜æœºåˆ¶æé«˜æ€§èƒ½

### æŠ€æœ¯ä¼˜åŠ¿
1. **å¯æ‰©å±•æ€§**ï¼šæ·»åŠ æ–°è¯­è¨€åªéœ€å®ç°æ¥å£è§„èŒƒ
2. **æ€§èƒ½ä¼˜åŒ–**ï¼šç¼“å­˜ã€æ‡’åŠ è½½ã€Web Workers ç­‰ä¼˜åŒ–ç­–ç•¥
3. **é”™è¯¯å¤„ç†**ï¼šå®Œå–„çš„é”™è¯¯å¤„ç†å’Œè°ƒè¯•å·¥å…·
4. **ç±»å‹å®‰å…¨**ï¼šå®Œæ•´çš„ TypeScript ç±»å‹å®šä¹‰

### æ”¯æŒèŒƒå›´
1. **ä¼ ç»Ÿè¯­è¨€**ï¼šJavaScriptã€TypeScriptã€Pythonã€Ruby ç­‰
2. **ç°ä»£æ¡†æ¶**ï¼šReactã€Vueã€Svelteã€Solid ç­‰
3. **WebAssembly**ï¼šé€šè¿‡ WASM æ”¯æŒæ›´å¤šè¯­è¨€
4. **æ¨¡æ¿è¯­è¨€**ï¼šå„ç§æ¨¡æ¿å¼•æ“å’Œæ ‡è®°è¯­è¨€
5. **æ ·å¼è¯­è¨€**ï¼šCSS é¢„å¤„ç†å™¨å’Œåå¤„ç†å™¨

è¿™ç§è®¾è®¡ä½¿å¾— LiveCodes èƒ½å¤Ÿåœ¨æµè§ˆå™¨ä¸­æä¾›æ¥è¿‘æœ¬åœ°å¼€å‘ç¯å¢ƒçš„å¤šè¯­è¨€æ”¯æŒä½“éªŒã€‚
```
