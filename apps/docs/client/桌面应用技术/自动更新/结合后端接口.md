# ç»“åˆ åç«¯æ¥å£ å®ç°è‡ªåŠ¨æ›´æ–°

## ç®€ä»‹

é€šè¿‡ä½¿ç”¨ electron-builder ä¸å’Œ electron-updaterï¼Œç»“åˆ åç«¯æ¥å£ å¯ä»¥å®ç°è‡ªåŠ¨æ›´æ–°ã€‚

## æ­¥éª¤ 1: åˆ›å»ºå¯¹åº”åç«¯æ¥å£

## æ­¥éª¤ 2: é…ç½® electron-builder.yml æ–‡ä»¶

```js
publish:
  - provider: generic
    url: 'your .exe file download_url ç›®å½•'
    updaterCacheDirName: 'file name'
```

## æ­¥éª¤ 3: é…ç½® upload.ts æ–‡ä»¶

```js
iimport { app, BrowserWindow, ipcMain } from 'electron'
import { autoUpdater } from 'electron-updater'
import log from 'electron-log'
import axios from 'axios'
// å…¨å±€å˜é‡ï¼Œç”¨äºå­˜å‚¨ä¸»çª—å£å¼•ç”¨
let mainWindow: BrowserWindow | null = null

// ç‰ˆæœ¬ä¿¡æ¯æ¥å£åœ°å€
const VERSION_API_URL = 'your-version-api-url'

// ç‰ˆæœ¬ä¿¡æ¯æ¥å£è¿”å›çš„æ•°æ®ç»“æ„
interface VersionInfo {
  current_version: string
  description: string
  download_url: string
  release_date: string
  update_available: boolean
}

/**
 * è®¾ç½®ä¸»çª—å£å¼•ç”¨
 * @param window ä¸»çª—å£å®ä¾‹
 */
export function setMainWindow(window: BrowserWindow | null) {
  mainWindow = window
}

/**
 * å‘é€æ—¥å¿—æ¶ˆæ¯åˆ°æ¸²æŸ“è¿›ç¨‹
 * @param type æ¶ˆæ¯ç±»å‹
 * @param msg æ¶ˆæ¯å†…å®¹
 */
function sendLogMessage(type: 'info' | 'success' | 'warning' | 'error', msg: string) {
  if (mainWindow) {
    mainWindow.webContents.send('log-message', { type, msg })
  }
}

/**
 * è®¾ç½®è‡ªåŠ¨æ›´æ–°
 */
export function setupAutoUpdater() {
  // é…ç½®autoUpdater
  autoUpdater.autoDownload = false
  autoUpdater.autoInstallOnAppQuit = false

  /**
   * è·å–æ›´æ–°å†…å®¹æ–‡æœ¬
   * @param updataUrl åŸºç¡€URL
   * @returns æ›´æ–°å†…å®¹æ–‡æœ¬
   */
  async function fetchUpdateContent(updataUrl: string): Promise<string> {
    try {
      sendLogMessage('info', 'æ­£åœ¨è·å–æ›´æ–°å†…å®¹: ' + updataUrl)

      const response = await axios.get(updataUrl)

      const content = response.data
      sendLogMessage('info', 'æˆåŠŸè·å–æ›´æ–°å†…å®¹')
      return content.trim()
    } catch (error) {
      sendLogMessage('error', 'è·å–æ›´æ–°å†…å®¹å¤±è´¥: ' + error.message)
      return ''
    }
  }

  // æ£€æŸ¥æ›´æ–°
  ipcMain.handle('check-for-updates', async () => {
    try {
      sendLogMessage('info', 'æ­£åœ¨è¯·æ±‚ç‰ˆæœ¬ä¿¡æ¯: ' + VERSION_API_URL)
      const response = await axios.post(
        VERSION_API_URL,
        {
          type: 'win10'
        },
        {
          method: 'post',
          headers: {
            'Content-Type': 'application/json'
          }
        }
      )
      sendLogMessage('info', 'æœåŠ¡å™¨å“åº”çŠ¶æ€: ' + response.status + ' ' + response.statusText)

      const versionInfo: VersionInfo = response.data
      const currentVersion = app.getVersion()
      sendLogMessage('info', 'å½“å‰ç‰ˆæœ¬: ' + currentVersion)

      // è·å–æ›´æ–°å†…å®¹
      let updateContent = ''
      if (versionInfo.update_available) {
        const updataUrl = versionInfo.release_date

        updateContent = await fetchUpdateContent(updataUrl)
      }

      // æ„é€ ä¸electron-updaterå…¼å®¹çš„è¿”å›æ ¼å¼
      const updateInfo = {
        version: versionInfo.current_version,
        releaseNotes: versionInfo.description ? [versionInfo.description] : [],
        releaseDate: versionInfo.release_date,
        updateAvailable: versionInfo.update_available,
        updateContent: updateContent
      }

      if (versionInfo.update_available) {
        // é…ç½®autoUpdaterçš„ä¸‹è½½URL
        if (versionInfo.download_url) {
          const baseUrl = versionInfo.download_url.substring(
            0,
            versionInfo.download_url.lastIndexOf('/')
          )

          sendLogMessage('info', 'è®¾ç½®ä¸‹è½½åŸºç¡€URL: ' + baseUrl)

          // æµ‹è¯•latest.ymlæ˜¯å¦å¯è®¿é—®
          try {
            const testYmlUrl = `${baseUrl}/latest.yml`
            sendLogMessage('info', 'æµ‹è¯•latest.yml URL: ' + testYmlUrl)
            axios
              .head(testYmlUrl, { method: 'HEAD' })
              .then((response) => {
                if (response.status === 200) {
                  sendLogMessage('info', 'latest.ymlå¯è®¿é—®ï¼ŒçŠ¶æ€ç : ' + response.status)
                } else {
                  sendLogMessage('warning', 'latest.ymlä¸å¯è®¿é—®ï¼ŒçŠ¶æ€ç : ' + response.status)
                }
              })
              .catch((err) => {
                sendLogMessage('error', 'æµ‹è¯•latest.ymlå¤±è´¥: ' + err.message)
              })
          } catch (testError) {
            sendLogMessage('error', 'æµ‹è¯•latest.ymlå‡ºé”™: ' + testError.message)
          }

          autoUpdater.setFeedURL({
            provider: 'generic',
            url: baseUrl
          })
        } else {
          // ä½¿ç”¨é»˜è®¤ä¸‹è½½URL
          autoUpdater.setFeedURL({
            provider: 'generic',
            url: 'your latest.yml file download_url ç›®å½•'
          })
        }

        // é€šçŸ¥æ¸²æŸ“è¿›ç¨‹æœ‰å¯ç”¨æ›´æ–°
        if (mainWindow) {
          mainWindow.webContents.send('update-available', updateInfo)
        }
      }

      return { updateInfo }
    } catch (error) {
      sendLogMessage('error', 'æ£€æŸ¥æ›´æ–°å¤±è´¥: ' + error.message)
      return { error: error.message }
    }
  })

  // æ·»åŠ è·å–åº”ç”¨ç‰ˆæœ¬å·çš„å¤„ç†ç¨‹åº
  ipcMain.handle('get-app-version', () => {
    return app.getVersion()
  })

  // æ·»åŠ ä¸‹è½½æ›´æ–°å¤„ç†ç¨‹åº
  ipcMain.handle('download-update', async () => {
    try {
      // æ¸…é™¤ä¹‹å‰çš„æ‰€æœ‰ç›‘å¬å™¨ï¼Œé¿å…é‡å¤
      autoUpdater.removeAllListeners()
      // è®°å½•å½“å‰çš„ä¸‹è½½URLé…ç½®
      sendLogMessage('info', 'å¼€å§‹å‡†å¤‡ä¸‹è½½æ›´æ–°...')
      // è®¾ç½®ä¸‹è½½è¿›åº¦ç›‘å¬
      autoUpdater.on('download-progress', (progressObj) => {
        sendLogMessage('info', 'ä¸‹è½½è¿›åº¦: ' + progressObj.percent + '%')
        if (mainWindow) {
          mainWindow.webContents.send('download-progress', { percent: progressObj.percent })
        }
      })

      // è®¾ç½®ä¸‹è½½å®Œæˆç›‘å¬
      autoUpdater.on('update-downloaded', (info) => {
        sendLogMessage('success', 'æ›´æ–°ä¸‹è½½å®Œæˆ: ' + info.version)
        if (mainWindow) {
          mainWindow.webContents.send('update-downloaded', {
            version: info.version,
            releaseDate: info.releaseDate
          })
        }
      })

      // æ·»åŠ é”™è¯¯ç›‘å¬
      autoUpdater.on('error', (error) => {
        sendLogMessage('error', 'æ›´æ–°ä¸‹è½½é”™è¯¯: ' + error.message)
        // å°†é”™è¯¯ä¿¡æ¯å‘é€åˆ°æ¸²æŸ“è¿›ç¨‹
        if (mainWindow) {
          mainWindow.webContents.send('update-error', { message: error.message })
        }
      })

      // æ·»åŠ æ—¥å¿—ç›‘å¬
      autoUpdater.logger = log
      autoUpdater.logger.transports.file.level = 'debug'

      // å¼€å§‹ä¸‹è½½
      sendLogMessage('info', 'å¼€å§‹ä¸‹è½½æ›´æ–°...')
      // å°è¯•æ‰‹åŠ¨æ£€æŸ¥æ›´æ–°æ–‡ä»¶
      try {
        const url = 'your latest.yml download_url ç›®å½•'
        const latestYmlUrl = `${url}/latest.yml`
        sendLogMessage('info', 'å°è¯•è·å–latest.yml: ' + latestYmlUrl)
        const response = await axios.get(latestYmlUrl)

        if (response.status === 200) {
          const ymlContent = await response.data
          sendLogMessage('info', `latest.ymlå†…å®¹å‰100å­—ç¬¦: ${ymlContent.substring(0, 100)}...`)
          // éªŒè¯ymlå†…å®¹æ˜¯å¦åŒ…å«å¿…è¦çš„å­—æ®µ
          if (!ymlContent.includes('path:') || !ymlContent.includes('sha512:')) {
            sendLogMessage('error', 'latest.ymlæ ¼å¼ä¸æ­£ç¡®ï¼Œç¼ºå°‘å¿…è¦å­—æ®µ')
            throw new Error('latest.ymlæ ¼å¼ä¸æ­£ç¡®ï¼Œç¼ºå°‘å¿…è¦å­—æ®µ')
          }
        } else {
          sendLogMessage('warning', `æ— æ³•è·å–latest.ymlï¼ŒçŠ¶æ€ç : ${response.status}`)
          throw new Error(`æ— æ³•è·å–latest.ymlï¼ŒçŠ¶æ€ç : ${response.status}`)
        }
      } catch (checkError) {
        sendLogMessage('error', `æ£€æŸ¥latest.ymlå¤±è´¥: ${checkError.message}`)
        return { error: checkError.message }
      }

      // ç¡®ä¿autoUpdateré…ç½®æ­£ç¡®
      autoUpdater.setFeedURL({
        provider: 'generic',
        url: 'your latest.yml download_url ç›®å½•'
      })

      // æ·»åŠ è¿™ä¸€è¡Œï¼šå…ˆæ£€æŸ¥æ›´æ–°
      sendLogMessage('info', 'æ£€æŸ¥æ›´æ–°...')
      await autoUpdater.checkForUpdates()

      autoUpdater.downloadUpdate().catch((err) => {
        sendLogMessage('error', `ä¸‹è½½æ›´æ–°å¤±è´¥: ${err.message}`)
        if (mainWindow) {
          mainWindow.webContents.send('update-error', { message: err.message })
        }
        throw err
      })

      return { success: true }
    } catch (error) {
      sendLogMessage('error', 'ä¸‹è½½æ›´æ–°å¤±è´¥: ' + error.message)
      return { error: error.message }
    }
  })

  // æ·»åŠ å®‰è£…å¹¶é‡å¯åº”ç”¨å¤„ç†ç¨‹åº
  ipcMain.on('install-and-restart', () => {
    autoUpdater.quitAndInstall(false, true)
  })
}
```

## æ­¥éª¤ 4: é…ç½® index.ts æ–‡ä»¶

```js
import { app, shell, BrowserWindow, ipcMain, Tray, Menu } from "electron";
import { join } from "path";
import { electronApp, optimizer, is } from "@electron-toolkit/utils";
import { setupUpdate } from "./update";

let mainWindow: BrowserWindow | null = null;

function createWindow(): void {
  const iconPath = join(__dirname, "../../resources/icon.png");
  mainWindow = new BrowserWindow({
    width: 900,
    height: 670,
    show: false,
    autoHideMenuBar: true,
    icon: iconPath,
    ...(process.platform === "linux" ? { iconPath } : {}),
    webPreferences: {
      preload: join(__dirname, "../preload/index.js"),
      sandbox: false,
    },
    frame: false,
    transparent: true,
  });

  mainWindow.on('ready-to-show', () => {
    setMainWindow(mainWindow)
  })

  // è·å–åº”ç”¨æ›´æ–°
  export function initWindows(): void {
    setupAutoUpdater()
  };
}
```

## æ­¥éª¤ 5: é…ç½® package.json æ–‡ä»¶

```js
"scripts": {
    "build": "electron-vite build",
    "build:win": "npm run build && electron-builder --win --config --publish always",
  }
```

## æ­¥éª¤ 6: æ‰“åŒ…åä¼šåœ¨æœ¬åœ°releaseç›®å½•ä¸‹ç”Ÿæˆä¸€ä¸ªæ–°çš„ç‰ˆæœ¬ç›®å½•, å°†å…¶ä¸­çš„.exe æ–‡ä»¶å’Œlatest.yml æ–‡ä»¶é€šè¿‡è„šæœ¬æ‰“åŒ…ä¸Šä¼ åˆ°æœåŠ¡å™¨æˆ–è€…è…¾è®¯äº‘å‚¨å­˜æ¡¶.

```js
const fs = require("fs");
const path = require("path");
const archiver = require("archiver");
const axios = require("axios");
const FormData = require("form-data");
const http = require("http");
const https = require("https");
const COS = require("cos-nodejs-sdk-v5");
// é…ç½®
const RELEASE_DIR = "./release";
const UPDATE_SERVER_URL = "your update server url";
const TEMP_ZIP_PATH = "./update-files.zip";

// è…¾è®¯äº‘COSé…ç½®
const COS_CONFIG = {
  SecretId: "", // SecretId
  SecretKey: "", // SecretKey
  Region: "", // å­˜å‚¨æ¡¶åœ°åŒº
  Bucket: "", // å­˜å‚¨æ¡¶åç§°
};

const cos = new COS({
  SecretId: COS_CONFIG.SecretId,
  SecretKey: COS_CONFIG.SecretKey,
});

// åˆ›å»ºè‡ªå®šä¹‰çš„ HTTP Agent é…ç½®
const httpAgent = new http.Agent({
  keepAlive: true,
  keepAliveMsecs: 30000,
  maxSockets: 5,
  maxFreeSockets: 2,
  timeout: 300000, // 5åˆ†é’Ÿè¶…æ—¶
});

const httpsAgent = new https.Agent({
  keepAlive: true,
  keepAliveMsecs: 30000,
  maxSockets: 5,
  maxFreeSockets: 2,
  timeout: 300000, // 5åˆ†é’Ÿè¶…æ—¶
});

/**
 * è·å–æœ€æ–°ç‰ˆæœ¬çš„æ–‡ä»¶å¤¹
 * @returns {string} æœ€æ–°ç‰ˆæœ¬çš„æ–‡ä»¶å¤¹è·¯å¾„
 */
const getLatestVersionFolder = () => {
  // è¯»å–releaseç›®å½•ä¸‹çš„æ‰€æœ‰æ–‡ä»¶å¤¹
  const versionFolders = fs
    .readdirSync(RELEASE_DIR)
    .filter((folder) => {
      const folderPath = path.join(RELEASE_DIR, folder);
      return (
        fs.statSync(folderPath).isDirectory() && /^\d+\.\d+\.\d+$/.test(folder)
      );
    })
    .sort((a, b) => {
      // æŒ‰ç‰ˆæœ¬å·æ’åºï¼ˆå‡è®¾ç‰ˆæœ¬å·æ ¼å¼ä¸ºx.y.zï¼‰
      const versionA = a.split(".").map(Number);
      const versionB = b.split(".").map(Number);

      for (let i = 0; i < 3; i++) {
        if (versionA[i] !== versionB[i]) {
          return versionB[i] - versionA[i]; // é™åºæ’åˆ—ï¼Œæœ€æ–°ç‰ˆæœ¬åœ¨å‰
        }
      }
      return 0;
    });

  if (versionFolders.length === 0) {
    throw new Error("æ²¡æœ‰æ‰¾åˆ°ä»»ä½•ç‰ˆæœ¬æ–‡ä»¶å¤¹");
  }

  const latestVersion = versionFolders[0];
  console.info(`æ‰¾åˆ°æœ€æ–°ç‰ˆæœ¬: ${latestVersion}`);
  return path.join(RELEASE_DIR, latestVersion);
};

/**
 * åˆ›å»ºåŒ…å«.exeå’Œlatest.ymlæ–‡ä»¶çš„å‹ç¼©åŒ…
 * @param {string} sourceFolder æºæ–‡ä»¶å¤¹è·¯å¾„
 * @param {string} targetZip ç›®æ ‡å‹ç¼©åŒ…è·¯å¾„
 * @returns {Promise<void>}
 */
const createUpdatePackage = (sourceFolder, targetZip) => {
  return new Promise((resolve, reject) => {
    console.info(`ä» ${sourceFolder} åˆ›å»ºæ›´æ–°åŒ…...`);

    // æ£€æŸ¥æ–‡ä»¶æ˜¯å¦å­˜åœ¨
    const exeFiles = fs
      .readdirSync(sourceFolder)
      .filter((file) => file.endsWith(".exe") && !file.endsWith(".blockmap"));
    if (exeFiles.length === 0) {
      return reject(new Error("æ²¡æœ‰æ‰¾åˆ°.exeå®‰è£…æ–‡ä»¶"));
    }

    const latestYmlPath = path.join(sourceFolder, "latest.yml");
    if (!fs.existsSync(latestYmlPath)) {
      return reject(new Error("æ²¡æœ‰æ‰¾åˆ°latest.ymlæ–‡ä»¶"));
    }

    // æ£€æŸ¥æ ¹ç›®å½•ä¸‹çš„updata.txtæ–‡ä»¶
    const updataTxtPath = path.join(process.cwd(), "updata.txt");
    if (!fs.existsSync(updataTxtPath)) {
      console.warn("è­¦å‘Š: æ²¡æœ‰æ‰¾åˆ°updata.txtæ–‡ä»¶ï¼Œå°†è·³è¿‡è¯¥æ–‡ä»¶");
    }

    // åˆ›å»ºå‹ç¼©åŒ…
    const output = fs.createWriteStream(targetZip);
    const archive = archiver("zip", {
      zlib: { level: 9 }, // æœ€é«˜å‹ç¼©çº§åˆ«
    });

    output.on("close", () => {
      console.info(
        `å‹ç¼©å®Œæˆï¼Œæ–‡ä»¶å¤§å°: ${(archive.pointer() / 1024 / 1024).toFixed(2)} MB`
      );
      resolve();
    });

    archive.on("error", (err) => reject(err));
    archive.pipe(output);

    // æ·»åŠ .exeæ–‡ä»¶
    exeFiles.forEach((exeFile) => {
      const exeFilePath = path.join(sourceFolder, exeFile);
      archive.file(exeFilePath, { name: exeFile });
      console.info(`æ·»åŠ æ–‡ä»¶: ${exeFile}`);
    });

    // æ·»åŠ latest.ymlæ–‡ä»¶
    archive.file(latestYmlPath, { name: "latest.yml" });
    console.info("æ·»åŠ æ–‡ä»¶: latest.yml");

    // æ·»åŠ updata.txtæ–‡ä»¶ï¼ˆå¦‚æœå­˜åœ¨ï¼‰
    if (fs.existsSync(updataTxtPath)) {
      archive.file(updataTxtPath, { name: "updata.txt" });
      console.info("æ·»åŠ æ–‡ä»¶: updata.txt");
    }

    archive.finalize();
  });
};

/**
 * ä¸Šä¼ æ–‡ä»¶åˆ°æ›´æ–°æœåŠ¡å™¨ï¼ˆå¸¦é‡è¯•æœºåˆ¶ï¼‰
 * @param {string} filePath è¦ä¸Šä¼ çš„æ–‡ä»¶è·¯å¾„
 * @param {number} maxRetries æœ€å¤§é‡è¯•æ¬¡æ•°
 * @returns {Promise<boolean>} ä¸Šä¼ æ˜¯å¦æˆåŠŸ
 */
const uploadToServer = async (filePath, maxRetries = 3) => {
  console.info(`å¼€å§‹ä¸Šä¼  ${filePath} åˆ° ${UPDATE_SERVER_URL}...`);

  const fileStats = fs.statSync(filePath);
  const fileSizeInMB = (fileStats.size / 1024 / 1024).toFixed(2);
  console.info(`æ–‡ä»¶å¤§å°: ${fileSizeInMB} MB`);

  for (let attempt = 1; attempt <= maxRetries; attempt++) {
    console.info(`å°è¯•ä¸Šä¼  (${attempt}/${maxRetries})...`);

    try {
      const formData = new FormData();
      const fileStream = fs.createReadStream(filePath);

      // ç›‘å¬æ–‡ä»¶æµé”™è¯¯
      fileStream.on("error", (err) => {
        console.error("æ–‡ä»¶æµé”™è¯¯:", err.message);
      });

      formData.append("file", fileStream);
      formData.append("type", "win10");

      // é…ç½®è¯·æ±‚é€‰é¡¹
      const config = {
        headers: {
          ...formData.getHeaders(),
          Connection: "close",
          "User-Agent": "Upload-Script/1.0",
        },
        timeout: 120000, // 2åˆ†é’Ÿè¶…æ—¶
        maxContentLength: Infinity,
        maxBodyLength: Infinity,
        validateStatus: function (status) {
          return status >= 200 && status < 300;
        },
        // ä¸Šä¼ è¿›åº¦ç›‘æ§
        onUploadProgress: (progressEvent) => {
          if (progressEvent.total) {
            const percentCompleted = Math.round(
              (progressEvent.loaded * 100) / progressEvent.total
            );
            if (percentCompleted % 10 === 0) {
              console.info(`ä¸Šä¼ è¿›åº¦: ${percentCompleted}%`);
            }
          }
        },
      };

      const response = await axios.post(UPDATE_SERVER_URL, formData, config);

      // å®Œå–„å“åº”å¤„ç†é€»è¾‘
      console.info("æœåŠ¡å™¨å“åº”çŠ¶æ€:", response.status);
      console.info("æœåŠ¡å™¨å“åº”æ•°æ®:", response.data);

      // æ£€æŸ¥å“åº”æ ¼å¼å’ŒæˆåŠŸçŠ¶æ€
      if (response.data && typeof response.data === "object") {
        if (response.data.success === true) {
          console.info("âœ… ä¸Šä¼ æˆåŠŸ!");
          if (response.data.message) {
            console.info("ğŸ“ æœåŠ¡å™¨æ¶ˆæ¯:", response.data.message);
          }
          return true;
        } else {
          // å¤„ç† success: false çš„æƒ…å†µ
          const errorMessage =
            response.data.message ||
            response.data.error ||
            "æœåŠ¡å™¨è¿”å›å¤±è´¥çŠ¶æ€";
          console.error("âŒ ä¸Šä¼ å¤±è´¥:", errorMessage);
          if (attempt === maxRetries) {
            return false;
          }
        }
      } else {
        // å¤„ç†å“åº”æ ¼å¼ä¸æ­£ç¡®çš„æƒ…å†µ
        console.error("âŒ æœåŠ¡å™¨å“åº”æ ¼å¼å¼‚å¸¸:", response.data);
        if (attempt === maxRetries) {
          return false;
        }
      }

      // é‡è¯•å‰ç­‰å¾…
      if (attempt < maxRetries) {
        console.info(`ç­‰å¾… ${attempt * 2} ç§’åé‡è¯•...`);
        await new Promise((resolve) => setTimeout(resolve, attempt * 2000));
      }
    } catch (error) {
      console.error(
        `âŒ ä¸Šä¼ å‡ºé”™ (å°è¯• ${attempt}/${maxRetries}):`,
        error.message
      );

      // è¯¦ç»†é”™è¯¯ä¿¡æ¯
      if (error.code) {
        console.error("é”™è¯¯ä»£ç :", error.code);
      }

      if (error.response) {
        console.error(
          "æœåŠ¡å™¨å“åº”çŠ¶æ€:",
          error.response.status,
          error.response.statusText
        );
        if (error.response.data) {
          console.error("æœåŠ¡å™¨å“åº”æ•°æ®:", error.response.data);

          // å°è¯•è§£æé”™è¯¯å“åº”ä¸­çš„æ¶ˆæ¯
          if (
            typeof error.response.data === "object" &&
            error.response.data.message
          ) {
            console.error("æœåŠ¡å™¨é”™è¯¯æ¶ˆæ¯:", error.response.data.message);
          }
        }
      } else if (error.request) {
        console.error("è¯·æ±‚é…ç½®:", {
          url: error.config?.url,
          method: error.config?.method,
          timeout: error.config?.timeout,
        });
        console.error("ç½‘ç»œé”™è¯¯: æ— æ³•è¿æ¥åˆ°æœåŠ¡å™¨æˆ–è¯·æ±‚è¶…æ—¶");
      } else {
        console.error("è¯·æ±‚è®¾ç½®é”™è¯¯:", error.message);
      }

      // å¦‚æœæ˜¯æœ€åä¸€æ¬¡å°è¯•ï¼Œè¿”å›å¤±è´¥
      if (attempt === maxRetries) {
        console.error("ğŸ”„ å·²è¾¾åˆ°æœ€å¤§é‡è¯•æ¬¡æ•°ï¼Œä¸Šä¼ å¤±è´¥");
        return false;
      }

      // ç­‰å¾…åé‡è¯•ï¼Œç­‰å¾…æ—¶é—´é€’å¢
      const waitTime = attempt * 5000;
      console.info(`ç­‰å¾… ${waitTime / 1000} ç§’åé‡è¯•...`);
      await new Promise((resolve) => setTimeout(resolve, waitTime));
    }
  }

  return false;
};

/**
 * ä¸Šä¼ æ–‡ä»¶åˆ°è…¾è®¯äº‘COSï¼ˆå¸¦é‡è¯•æœºåˆ¶ï¼‰
 * @param {string} filePath è¦ä¸Šä¼ çš„æ–‡ä»¶è·¯å¾„
 * @param {string} key COSä¸­çš„æ–‡ä»¶è·¯å¾„
 * @param {number} maxRetries æœ€å¤§é‡è¯•æ¬¡æ•°
 * @returns {Promise<boolean>} ä¸Šä¼ æ˜¯å¦æˆåŠŸ
 */
const uploadToCOS = async (filePath, key, maxRetries = 3) => {
  console.info(`å¼€å§‹ä¸Šä¼  ${filePath} åˆ°è…¾è®¯äº‘COS...`);

  const fileStats = fs.statSync(filePath);
  const fileSizeInMB = (fileStats.size / 1024 / 1024).toFixed(2);
  console.info(`æ–‡ä»¶å¤§å°: ${fileSizeInMB} MB`);

  for (let attempt = 1; attempt <= maxRetries; attempt++) {
    console.info(`å°è¯•ä¸Šä¼ åˆ°COS (${attempt}/${maxRetries})...`);

    try {
      const result = await new Promise((resolve, reject) => {
        cos.putObject(
          {
            Bucket: COS_CONFIG.Bucket,
            Region: COS_CONFIG.Region,
            Key: key,
            Body: fs.createReadStream(filePath),
            ContentLength: fileStats.size,
            onProgress: (progressData) => {
              const percentCompleted = Math.round(
                (progressData.loaded * 100) / progressData.total
              );
              if (percentCompleted % 10 === 0) {
                console.info(`COSä¸Šä¼ è¿›åº¦: ${percentCompleted}%`);
              }
            },
          },
          (err, data) => {
            if (err) {
              reject(err);
            } else {
              resolve(data);
            }
          }
        );
      });

      if (result.statusCode === 200) {
        console.info("âœ… è…¾è®¯äº‘COSä¸Šä¼ æˆåŠŸ!");
        console.info(
          "ğŸ“ COSæ–‡ä»¶åœ°å€:",
          `https://${COS_CONFIG.Bucket}.cos.${COS_CONFIG.Region}.myqcloud.com/${key}`
        );
        return true;
      } else {
        console.error("âŒ è…¾è®¯äº‘COSä¸Šä¼ å¤±è´¥!");
        return false;
      }
    } catch (error) {
      console.error(
        `âŒ COSä¸Šä¼ å‡ºé”™ (å°è¯• ${attempt}/${maxRetries}):`,
        error.message
      );

      if (error.code) {
        console.error("COSé”™è¯¯ä»£ç :", error.code);
      }

      // å¦‚æœæ˜¯æœ€åä¸€æ¬¡å°è¯•ï¼Œè¿”å›å¤±è´¥
      if (attempt === maxRetries) {
        console.error("ğŸ”„ COSå·²è¾¾åˆ°æœ€å¤§é‡è¯•æ¬¡æ•°ï¼Œä¸Šä¼ å¤±è´¥");
        return false;
      }

      // ç­‰å¾…åé‡è¯•ï¼Œç­‰å¾…æ—¶é—´é€’å¢
      const waitTime = attempt * 3000;
      console.info(`ç­‰å¾… ${waitTime / 1000} ç§’åé‡è¯•COSä¸Šä¼ ...`);
      await new Promise((resolve) => setTimeout(resolve, waitTime));
    }
  }

  return false;
};

/**
 * ä¸Šä¼ .exeæ–‡ä»¶åˆ°è…¾è®¯äº‘COS
 * @param {string} sourceFolder æºæ–‡ä»¶å¤¹è·¯å¾„
 * @returns {Promise<boolean>} ä¸Šä¼ æ˜¯å¦æˆåŠŸ
 */
const uploadExeFilesToCOS = async (sourceFolder) => {
  console.info("ğŸ” æŸ¥æ‰¾.exeæ–‡ä»¶...");

  // è·å–æ‰€æœ‰.exeæ–‡ä»¶
  const exeFiles = fs
    .readdirSync(sourceFolder)
    .filter((file) => file.endsWith(".exe") && !file.endsWith(".blockmap"));

  if (exeFiles.length === 0) {
    console.error("âŒ æ²¡æœ‰æ‰¾åˆ°.exeæ–‡ä»¶");
    return false;
  }

  const latestYmlPath = path.join(sourceFolder, "latest.yml");
  if (!fs.existsSync(latestYmlPath)) {
    console.error("âŒ æ²¡æœ‰æ‰¾åˆ°latest.ymlæ–‡ä»¶");
    return false;
  }

  console.info(`æ‰¾åˆ° ${exeFiles.length} ä¸ª.exeæ–‡ä»¶:`, exeFiles);

  // ä¸Šä¼ æ¯ä¸ª.exeæ–‡ä»¶
  for (const exeFile of exeFiles) {
    const exeFilePath = path.join(sourceFolder, exeFile);
    const cosKey = `win10/${exeFile}`; // COSä¸­çš„æ–‡ä»¶è·¯å¾„

    console.info(`ğŸ“¤ ä¸Šä¼  ${exeFile} åˆ°è…¾è®¯äº‘COS...`);
    const uploadSuccess = await uploadToCOS(exeFilePath, cosKey);

    if (!uploadSuccess) {
      console.error(`âŒ ${exeFile} ä¸Šä¼ å¤±è´¥`);
      return false;
    }

    console.info(`âœ… ${exeFile} ä¸Šä¼ æˆåŠŸ`);
  }

  // ä¸Šä¼ latest.ymlæ–‡ä»¶
  console.info("ğŸ“¤ ä¸Šä¼  latest.yml åˆ°è…¾è®¯äº‘COS...");
  const ymlUploadSuccess = await uploadToCOS(latestYmlPath, "win10/latest.yml");

  if (!ymlUploadSuccess) {
    console.error("âŒ latest.yml ä¸Šä¼ å¤±è´¥");
    return false;
  }

  console.info("âœ… latest.yml ä¸Šä¼ æˆåŠŸ");

  // æ£€æŸ¥å¹¶ä¸Šä¼ updata.txtæ–‡ä»¶ï¼ˆå¦‚æœå­˜åœ¨ï¼‰
  const updataTxtPath = path.join(process.cwd(), "updata.txt");
  if (fs.existsSync(updataTxtPath)) {
    console.info("ğŸ“¤ ä¸Šä¼  updata.txt åˆ°è…¾è®¯äº‘COS...");
    const txtUploadSuccess = await uploadToCOS(
      updataTxtPath,
      "win10/updata.txt"
    );

    if (txtUploadSuccess) {
      console.info("âœ… updata.txt ä¸Šä¼ æˆåŠŸ");
    } else {
      console.warn("âš ï¸ updata.txt ä¸Šä¼ å¤±è´¥ï¼Œä½†ä¸å½±å“ä¸»è¦åŠŸèƒ½");
    }
  }

  return true;
};

/**
 * æ¸…ç†ä¸´æ—¶æ–‡ä»¶
 */
const cleanup = () => {
  if (fs.existsSync(TEMP_ZIP_PATH)) {
    fs.unlinkSync(TEMP_ZIP_PATH);
    console.info(`å·²åˆ é™¤ä¸´æ—¶æ–‡ä»¶: ${TEMP_ZIP_PATH}`);
  }
};

/**
 * ä¸»å‡½æ•°
 */
const main = async () => {
  try {
    console.info("ğŸš€ å¼€å§‹æ„å»ºå’Œä¸Šä¼ æ›´æ–°åŒ…...");

    // æ¸…ç†ä¹‹å‰çš„ä¸´æ—¶æ–‡ä»¶
    cleanup();

    // è·å–æœ€æ–°ç‰ˆæœ¬æ–‡ä»¶å¤¹
    const latestVersionFolder = getLatestVersionFolder();

    // åˆ›å»ºæ›´æ–°åŒ…
    console.info("ğŸ“¦ åˆ›å»ºæ›´æ–°åŒ…...");
    await createUpdatePackage(latestVersionFolder, TEMP_ZIP_PATH);

    // ä¸Šä¼ åˆ°æœåŠ¡å™¨
    console.info("â¬†ï¸ ä¸Šä¼ åˆ°æœåŠ¡å™¨...");
    const uploadSuccess = await uploadToServer(TEMP_ZIP_PATH);

    if (uploadSuccess) {
      console.info("âœ… æ›´æ–°æ–‡ä»¶å·²æˆåŠŸä¸Šä¼ åˆ°æœåŠ¡å™¨");
      // ä¸Šä¼ åˆ°è…¾è®¯äº‘COS
      console.info("â˜ï¸ ä¸Šä¼ åˆ°è…¾è®¯äº‘COS...");
      const cosUploadSuccess = await uploadExeFilesToCOS(latestVersionFolder);

      if (cosUploadSuccess) {
        console.info("âœ… .exeæ–‡ä»¶å·²æˆåŠŸä¸Šä¼ åˆ°è…¾è®¯äº‘COS");
        cleanup();
        console.info("ğŸ—‘ï¸ å·²æ¸…ç†ä¸´æ—¶æ–‡ä»¶");
        process.exit(0);
      } else {
        console.error("âŒ .exeæ–‡ä»¶ä¸Šä¼ åˆ°è…¾è®¯äº‘COSå¤±è´¥");
        process.exit(1);
      }
    } else {
      console.error("âŒ æ›´æ–°æ–‡ä»¶ä¸Šä¼ å¤±è´¥");
      process.exit(1);
    }
  } catch (error) {
    console.error("ğŸ’¥ å‘ç”Ÿé”™è¯¯:", error.message);
    console.error("é”™è¯¯å †æ ˆ:", error.stack);
    process.exit(1);
  } finally {
    // æ¸…ç†ä¸´æ—¶æ–‡ä»¶
    cleanup();

    // æ¸…ç†è¿æ¥æ± 
    httpAgent.destroy();
    httpsAgent.destroy();
  }
};

// å¤„ç†æœªæ•è·çš„å¼‚å¸¸
process.on("uncaughtException", (error) => {
  console.error("æœªæ•è·çš„å¼‚å¸¸:", error);
  cleanup();
  process.exit(1);
});

process.on("unhandledRejection", (reason) => {
  console.error("æœªå¤„ç†çš„ Promise æ‹’ç»:", reason);
  cleanup();
  process.exit(1);
});

// æ‰§è¡Œä¸»å‡½æ•°
main();
```

## æ€»ç»“

æ€»ä½“æ€è·¯å°±æ˜¯ï¼š

1. åˆ›å»ºå¯¹åº”çš„åç«¯ä¸Šä¼ æ–‡ä»¶æ¥å£, è·å–æ–‡ä»¶æ¥å£.
2. é…ç½® electron-builder.yml æ–‡ä»¶
3. é…ç½® upload.ts æ–‡ä»¶ï¼Œç›‘å¬ç”¨æˆ·çš„æ›´æ–°è¯·æ±‚ï¼Œä¸‹è½½æ›´æ–°ï¼Œå®‰è£…æ›´æ–°
4. é…ç½® index.ts æ–‡ä»¶ï¼Œç›‘å¬ç”¨æˆ·çš„æ›´æ–°è¯·æ±‚ï¼Œè·å–åº”ç”¨æ›´æ–°
5. é…ç½® package.json æ–‡ä»¶ï¼Œæ‰“åŒ…å‘½ä»¤ï¼Œå‘å¸ƒå‘½ä»¤
6. æ‰“åŒ…åå°†releaseç›®å½•ä¸‹çš„æ–‡ä»¶ä¸Šä¼ åˆ°æœåŠ¡å™¨
